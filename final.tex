\documentclass[12pt]{mwart}
%\documentclass{mwart}
\usepackage{makeidx}
\usepackage{polski}
%\usepackage{antpolt}
\usepackage[utf8]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage{graphics}
\usepackage[table]{xcolor}
\usepackage[bookmarks, pdfhighlight=/P, citebordercolor={1 1 1}, linkbordercolor={1 1 1}, unicode=true]{hyperref}
\usepackage{amsfonts}
\usepackage{verbatim}
\usepackage{multirow}
\usepackage{hhline}
\bibliographystyle{plunsrt}
\hyphenation{ wyj-ścia pier-wszego}
\newcommand{\code}{\texttt}

\makeindex

\newcommand{\remark}{{\bf \emph{Notatka:}} \\ \emph}
\newcommand{\dcolon}{::}
\newcommand{\procbr}{()}
\newcommand{\function}[1]{\code{#1\procbr}}

\newcounter{tabmain}
\setcounter{tabmain}{1}
\newcommand{\mytabcaption}[1]{ \begin{center}\parbox[t]{11.5cm}{\normalsize{Tabela \arabic{tabmain}. #1.}}\end{center} \addtocounter{tabmain}{1} }

\newcounter{figmain}
\setcounter{figmain}{1}
\newcommand{\myfigcounter}[1]{ \begin{center}\parbox[t]{11.5cm}{Rysunek \arabic{figmain}. #1.}\end{center} \addtocounter{figmain}{1} }
\newcommand{\myownfigure}[4]{ \newcounter{#1} \setcounter{#1}{\value{figmain}} \addtocounter{figmain}{1} \begin{center} \label{fig:#1} \centering \includegraphics[scale=#4, angle=0]{#2}\\ \nopagebreak[5] \parbox[t]{11.5cm}{Rysunek \arabic{#1}. #3.} \end{center}}

\usepackage{xtab}
\tabletail{\hline}

\usepackage{fancyhdr}
\setlength{\headheight}{15.2pt}
\pagestyle{fancy}
\lhead{\leftmark}
\chead{\empty}
\rhead{\rightmark}
\lfoot{\empty}
\cfoot{\thepage}
\rfoot{\empty}
%\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
%\renewcommand{\sectionmark}[1]{\markright{#1}{}}
\renewcommand{\sectionmark}[1]{\markboth{{#1}}{}}

\linespread{1.3}
%\linespread{1.3}
%\usepackage{qswiss,qcourier}
%\usepackage{sfheaders}

%\usepackage[layout]{tools}

%\setlength{\voffset}{1cm}
%\setlength{\voffset}{1cm}
\author{Mariusz Barycz}
\title{Analiza metod zarządzania wątkami mieszanymi}
\date{\today}
\begin{document} 


\maketitle
\thispagestyle{empty}

\newpage
\tableofcontents
\thispagestyle{empty}
\newpage

\section{Wstęp}
%
\subsection{Motywacja}
\label{sec:motivation}
\indent
  W większości współczesnych \emph{systemów operacyjnych} możliwe jest jednoczesne uruchomienie wielu
  programów użytkowych. W~komputerach posiadających dokładnie jeden procesor są one wykonywane \emph{współbieżnie}, tj. w~\emph{jądrze} systemu są używane mechanizmy do
  wykonywania każdego programu \emph{po kawałku} (np. opisany w~rozdziale \ref{sec:system} mechanizm \emph{wywłaszczania}). W~połączeniu
  z~szybkością działania współczesnych procesorów, użytkownik systemu ma wrażenie, że uruchomione przez niego programy wykonują się równocześnie.
  Umożliwia to efektywne wykorzystanie procesora, co pokazują poniższe przykłady:
  \begin{itemize}
    \item może on być wykorzystany do wykonania części pewnego programu,
      podczas gdy inny program oczekuje na wykonanie przez system operacyjny pewnego zadania (często związanego z~obsługą któregoś z~\emph{zasobów systemowych}) --
      w~ten sposób obydwa programy mogą być wykonane w~czasie o~wiele krótszym, niż gdyby wykonać najpierw pierwszy z~nich, a~następnie drugi;
    \item system operacyjny może monitorować działanie programu, a~w~sytuacji krytycznej (np. próba wykonania operacji niezgodnej z~polityką bezpieczeństwa systemu)
      niezwłocznie zareagować -- stosownie do rodzaju takiego zdarzenia.
  \end{itemize}
  Powyższe przykłady pokazują, że używanie współbieżnego systemu operacyjnego daje niebagatelne zyski jego użytkownikowi w~porównaniu do używania systemu operacyjnego
  bez zaimplementowanej współbieżności: komputer oraz jego zasoby mogą być wykorzystane wydajniej, zaś współbieżny system operacyjny działa o~wiele stabilniej.
\par
\indent
  Obecnie większość dostępnych komputerów to maszyny wieloprocesorowe (\emph{wielordzeniowe}, ang. \emph{multi-core}), a~więc umożliwiają
  \emph{równoległe} (ang. \emph{parallel}) wykonanie programów. Systemy operacyjne łączą współbieżność z~równoległością, co może dać korzyść w~postaci
  efektywnego wykorzystania wszystkich rdzeni dostępnych w~komputerze:
  \begin{itemize}
    \item współbieżność pozwala wykorzystać efektywnie czas każdego procesora z~osobna;
    \item równoległe wykonanie wielu programów zwiększa wydajność całego systemu operacyjnego -- może on obsłużyć więcej żądań użytkownika w~porównaniu do
      systemu działającego na komputerze posiadającym tylko jeden procesor.
  \end{itemize}
\par
\indent
  Pojęciem związanym zarówno ze współbieżnością, jak i~równoległym wykonaniem programów jest \emph{proces}: jest to wydzielony fragment programu (\emph{jednostka wykonalna})
  oraz powiązane z~nim zasoby systemu operacyjnego (bardziej szczegółowy opis procesu znajduje się w~rozdziale \ref{sec:system}),
  a~więc program użytkownika to co najmniej jeden proces.
\par
\indent
  Pojęciem, które niejako ,,wyrasta'' z~pojęcia procesu, jest \emph{wątek}. Wątek jest jednostką wykonalną, która jest wytwarzana przez jej \emph{proces macierzysty}.
  Jeden proces może wytworzyć wiele wątków, a~każdy z~nich może wykorzystywać te zasoby systemu operacyjnego, które są przydzielone ich procesowi macierzystemu.
  Wątki bywają również nazywane \emph{procesami wagi lekkiej} (ang. \emph{lightweight processes}, LWP) -- z~punktu widzenia jądra systemu operacyjnego
  ich obsługa jest o~wiele \emph{lżejsza}.
  Wiele systemów operacyjnych traktuje wątki w~specjalny sposób, przykładem może być obsługa wątków w~systemach z~rodziny Windows:
  wytworzenie i~uruchomienie nowego procesu zajmuje o~wiele więcej czasu niż wytworzenie nowego wątku. Wiele systemów
  udostępnia funkcje do wyłącznej obsługi wątków.
\par
%
\indent
  Oprócz LWP istnieją również implementacje wątków przestrzeni użytkownika. Można je scharakteryzować w~następujący sposób:
  \begin{itemize}
    \item posiadają własny stos wywołań;
    \item są wykonywane w~dokładnie jednym wątku przestrzeni jądra w~danym procesie.
  \end{itemize}
  Pouczającym przykładem implementacji takich wątków jest biblioteka GNU Pth \cite{pth}. Jej rozwój zatrzymał się w~roku 2006.
\par
%
\indent
\newcounter{userversuskernel} \setcounter{userversuskernel}{\value{tabmain}}
	Wątki przestrzeni jądra i~wątki przestrzeni użytkownika posiadają zarówno zalety jak i~wady. Są one wymienione w~Tabeli \arabic{userversuskernel}.
  \begin{center}
  \begin{tabular}{|c|p{5cm}|p{5cm}|} \hline
                & \multicolumn{1}{c|}{Wątki przestrzeni jądra} & \multicolumn{1}{c|}{Wątki przestrzeni użytkownika} \\ \hline
      Zalety    & -- zarządzanie wątkami (szeregowanie, uruchamianie i~destrukcja) są zadaniem jądra systemu operacyjnego; \par 
                  -- wykorzystanie wszystkich dostępnych rdzeni komputera; \par 
                  -- wszystkie udogodnienia systemowe dostępne bezpośrednio z~wątku; 
                & -- jądro systemu operacyjnego nie odpowiada za obsługę wątków: nawet duża granulacja wątków nie wpływa na spadek jego wydajności; \par
                  -- wątki nie są wywłaszczane, co pozwala na łatwe uniknięcie problemów z~synchronizacją;
                \\ \hline
      Wady      & -- wysoka granulacja wątków powoduje spadek wydajności systemu operacyjnego; \par
                  -- dostęp do współdzielonych zasobów może powodować problemy opisane w~rozdziale \ref{sec:synchro};
                & -- zarządzanie wątkami może spowodować spadek wydajności programu; \par
                  -- bezpośrednie wykorzystanie blokujących funkcji systemowych prowadzi do zablokowania pracy wszystkich wątków; dlatego
                     należy stworzyć warstwę pośrednią do korzystania z~zasobów systemu bez blokowania pracy innych wątków; \par
                  -- wątki mogą być uruchomione w~dokładnie jednym wątku bieżącego procesu: niemożliwe jest więc wykorzystanie wszystkich rdzeni dostępnych w~komputerze;
                \\ \hline
  \end{tabular}
  \mytabcaption{Porównanie zalet i~wad wątków przestrzeni jądra oraz użytkownika}
  \end{center}
\par
\indent
  Rozwiązaniem pośrednim pomiędzy wątkami przestrzeni jądra a~użytkownika są wątki \emph{mieszane} (\emph{hybrydowe}), zwane na potrzeby tej pracy \emph{włóknami}:
  \begin{enumerate}
    \item Mogą wykorzystać wszystkie rdzenie dostępne dla danego procesu: wytwarzane jest dokładnie tyle wątków przestrzeni jądra, ile jest dostępnych rdzeni.
      Następnie każdy taki wątek otrzymuje odpowiednią liczbę włókien, które będą wykonywane w~czasie przydzielonym dla tego wątku. Ta własność odróżnia włókna od
      wątków przestrzeni użytkownika. \label{hybridthread}
    \item Każde włókno posiada jedynie swój stos wywołań oraz własny licznik rozkazów (informację o~aktualnie wykonywanym rozkazie). Dzięki temu możliwe jest
      ,,zamrożenie'' włókna, a~następnie uruchomienie go od tego miejsca. Ta własność odróżnia włókna od wątków przestrzeni jądra.
    \item System operacyjny nie jest świadomy istnienia włókien: zarządza on jedynie wątkami, opisanych w~punkcie \ref{hybridthread}. Dzięki temu
      zadanie zarządzania włóknami nie wpływa na działanie systemu operacyjnego, a~co za tym idzie, na jego wydajność.
      Z~tego powodu po stronie programu użytkownika musi istnieć odpowiednia implementacja zarządcy włókien, która może z~kolei mieć wpływ na wydajność programu.
    \item Implementacja włókien w~systemie operacyjnym może wymagać zmian w~jądrze systemu, 
      jednak każda taka zmiana jest potencjalnym zagrożeniem dla wydajności systemu operacyjnego.
      Włókna można jednak zaimplementować przy użyciu istniejących mechanizmów oferowanych przez system operacyjny.
  \end{enumerate}
\par
%
\indent
  W~niniejszej pracy użycie słowa ,,wątek'' oznacza odwołanie do wątku przestrzeni jądra, zaś użycie słowa ,,włókno'' oznacza odwołanie
  do wątku mieszanego.
\par
%
\subsection{Cel pracy}
\label{sec:target}
\indent
  Celem niniejszej pracy było utworzenie biblioteki włókien w~języku C++.
	Powinna ona odpowiadać za:
	\begin{enumerate}
		\item Zarządzanie włóknem:
		\begin{itemize}
			\item tworzenie i~destrukcja;
			\item przydział kontekstu wykonania (stosu);
			\item przydział włókna do procesora;
			\item uruchomienie i~wstrzymanie (tzn. w~momencie wywołania operacji \function{yield});
			\item prawidłowa reakcja na wystąpienie wyjątku w~trakcie działania.
		\end{itemize}
		\item Komunikację: wysyłanie i~obsługa komunikatów (po stronie zarządcy i~włókna).
		\item Nieblokujący dostęp do  urządzeń wejścia\dywiz wyjścia (z~punktu widzenia zarządcy włókien).
    \item Zarządzanie kolejnością i~czasem wykonania włókien (ang. \emph{scheduling}). \label{enm:timesch}
	\end{enumerate}
\par
\indent
  Każdy z~trzech popularnych systemów operacyjnych (Windows, MacOS, systemy oparte na jądrze Linux), obsługuje procesy i~wątki, każdy na swój sposób. Systemy linuksowe,
  w~odróżnieniu od pozostałych dwóch, działają zarówno w~superkomputerach jak i~w~stacjach roboczych. Dlatego też docelowym systemem operacyjnym dla biblioteki
  powinien być system operacyjny oparty na jądrze Linuksa.
\par
\indent
  Większość obecnych komputerów to systemy wieloprocesorowe (wielordzeniowe). Dlatego też biblioteka włókien powinna wykorzystywać dostępne rdzenie, dzięki czemu będzie
  zasadniczo różnić się od każdej biblioteki wątków przestrzeni użytkownika (biblioteki te działają w~dokładnie jednym wątku przestrzeni jądra).
  Co więcej, celem jest stworzenie biblioteki włókien, która będzie wykorzystywać dostępne już w~systemie operacyjnym mechanizmy, bez wprowadzania modyfikacji w~jądrze
  systemu. Istnieje wiele implementacji (opisanych w~rozdziale \ref{sec:fibers}), które wymagają modyfikacji po stronie jądra systemu operacyjnego, zaś implementacja
  wykorzystująca dostępne mechanizmy dla wątków przestrzeni jądra i~użytkownika jak dotychczas nie została zaimplementowana, lub nie została zaprezentowana szerokiej publiczności.
\par
%
\subsection{Streszczenie pracy}
\indent
	\begin{itemize}
	\item[Rozdział \ref{sec:system}] opisuje obecne systemy komputerowe oraz współczesne systemy operacyjne. Rozdział ten opisuje także
    procesy, wątki i~włókna. Dodatkowo, opisane są mechanizmy używane do zarządzania oraz komunikacji pomiędzy nimi, jak również problemy
    związane z~ich zastosowaniem.
	\item[Rozdział \ref{sec:solution}] opisuje implementację włókien opartą na pomyśle opisanym we wstępie.
	\item[Rozdział \ref{sec:analysis}] określa wartość tej implementacji: jej użyteczność oraz wydajność.
	\item[Rozdział \ref{sec:summary}] podsumowuje wykonanie założeń opisanych we wstępie, jak również wyznacza możliwe drogi rozwoju
		powstałej implementacji.
	\end{itemize}
\par
%
\newpage
\section{System operacyjny}
%
\label{sec:system}
\subsection{Wstęp}
\indent 
	W~systemie komputerowym (lub w~skrócie: komputerze) można wyróżnić trzy podstawowe składowe:
	\begin{itemize}
		\item procesor (jednostka centralna, CPU): wykonuje rozkazy (instrukcje procesora);
		\item pamięć główna: przechowuje dane oraz programy. Pamięć w~tym kontekście jest z~natury ulotna (po wyłączeniu komputera,
			jej zawartości nie można odzyskać); jeśli w~treści dokumentu pojawi się słowo \emph{pamięć}, odwoływać się będzie ono do
			pamięci głównej;
		\item urządzenia zewnętrzne (peryferia, I/O): służą do wymiany danych pomiędzy komputerem i~światem zewnętrznym.
	\end{itemize}
	Komunikacja pomiędzy nimi odbywa się za pośrednictwem szyny systemowej (ang. \emph{system bus}).
	Dokładny opis architektury współczesnych
	systemów komputerowych można znaleźć w~\cite{hennessy}.
\par
\indent
	System operacyjny (ang. \emph{operating system, OS}, zwany dalej \emph{systemem}) jest programem, 
	który kontroluje wykonanie aplikacji użytkownika (programów),
	może być postrzegany jako pośrednik (interfejs) pomiędzy programem a~sprzętem (systemem komputerowym), na którym jest wykonywany.
	Najważniejszym zyskiem z~używania systemu jest możliwość uruchomienia programu napisanego dla jednego OS, który będzie działać na różnych systemach komputerowych.
\par
%
\indent
	Programy użytkownika wykonywane pod kontrolą systemu operacyjnego mogą być proste (np. program do zliczania słów w~pliku tekstowym)
	lub złożone (program do obsługi transakcji bankowych). OS musi zatem udostępniać pewną abstrakcję systemu komputerowego dostarczaną dla użytkownika,
  dzięki której możliwe będzie korzystanie z~zasobów komputera. Abstrakcja ta jest zrealizowana jako zbiór \emph{usług} (ang. \emph{services}) systemu operacyjnego.
  O~ile wskazane jest, aby użytkownik nie miał dostępu do wszystkich zasobów systemu operacyjnego, o~tyle usługi OS muszą mieć taki dostęp.
  Zbiór usług systemu jest zwany \emph{jądrem} (ang. \emph{kernel}), zaś tryb pracy systemu z~dostępem do wszystkich zasobów OS zwany jest
  \emph{przestrzenią jądra} (ang. \emph{kernel space}).
\par
%
\indent
  Zdecydowana większość obecnych systemów operacyjnych to systemy wielozadaniowe z~\emph{wywłaszczaniem} (ang. \emph{pre\dywiz emptive multitasking operating system})
  oraz \emph{zarządzaniem pamięcią} (ang. \emph{memory management}). Dlatego też w~dalszej części tego rozdziału opisane będą fragmenty takich właśnie systemów.
\par
%
\indent
  Mechanizm wywłaszczania można określić jako zatrzymanie bieżącego programu oraz zapis jego stanu.
\par
%
\indent
  Zarządzanie pamięcią osobno dla każdego programu pozwala na bezpieczne zarządzanie programami: jeśli jeden z~nich będzie próbował wykonać dowolną operację
  poza swoją \emph{przestrzenią adresową} (ang. \emph{address space}), system będzie mógł zareagować na taką próbę oraz poinformować odpowiedzialny za nią program
  o~jego nieprawidłowym działaniu.
\par
%
\indent
  Jedną z~ważnych usług systemu operacyjnego jest wytworzenie i~zarządzanie \emph{zadaniem} (ang. \emph{task}), zwanym również \emph{procesem}
  (ang. \emph{process}). Stan każdego procesu jest reprezentowany w~systemie przez \emph{blok kontrolny procesu} (ang. \emph{Process Control Block}, PCB).
  Zawiera on wszystkie informacje o~stanie odpowiadającego mu procesu, m. in.:
  \begin{itemize}
    \item unikatowy identyfikator procesu;
    \item kontekst wykonania procesu, tj. stan rejestrów procesora, licznik rozkazów, wskaźnik stosu;
    \item informacje o~pamięci przydzielonej dla procesu (jego przestrzeni adresowej);
    \item statystyki procesu: ilość zużytego czasu procesora, ilość wykonanych operacji wywłaszczenia, \ldots
    \item priorytet procesu;
    \item wskaźnik na następny PCB.
  \end{itemize}
  Jest to struktura zawierająca komplet informacji o~odpowiadającym jej zadaniu, dostępna jedynie z~poziomu przestrzeni jądra.
  Jądro systemu Linux w~wersji 3.1 wytwarza PCB o~rozmiarze ok. 1,7 KiB.
\par
%
\indent
  Procesy, jakie może uruchomić użytkownik, działać będą w~przestrzeni adresowej, która nazywana jest \emph{przestrzenią użytkownika} (ang. \emph{user space}), zaś
  system działa w~\emph{trybie użytkownika} (ang. \emph{user mode}). W~dokumencie, jeżeli nie jest zaznaczone inaczej,
  jeśli wystąpi pojęcie przestrzeni użytkownika, będzie ona utożsamiana z~procesem pracującym w~trybie użytkownika.
  Każdy program działający w~systemie operacyjnym składa się z~co najmniej jednego procesu.
\par
%
\indent
	Jądro systemu to jego podstawa, która jest odpowiedzialna za zarządzanie jego usługami, jak również zasobami, m. in. pamięcią, I/O,
	przydzielaniem czasu procesora poszczególnym procesom. Instrukcje procesu jądra wykonywane są w~\emph{przestrzeni jądra}
  (ang. \emph{kernel space}). Dzięki temu
	mają one dostęp do wszystkich zasobów systemu komputera i~mogą je dowolnie zmieniać. Dlatego też procesy uruchamiane w~przestrzeni
	jądra muszą być zaprojektowane zgodnie ze wszystkimi wymaganiami stawianymi danemu systemowi operacyjnemu, wraz z~podstawowym wymaganiem:
	muszą one być \emph{niezawodne}, gdyż w~razie wystąpienia poważnego błędu w~trakcie wykonywania programu uruchomionego w~przestrzeni jądra,
	działanie wszystkich aplikacji w~systemie zostanie zaburzone, a~w~konsekwencji może doprowadzić to do unicestwienia całego systemu operacyjnego.
\par
%
\subsection{Procesy}
\indent
  Jak wspomniano wyżej, każdy proces to dla systemu operacyjnego odpowiadający mu PCB, który jest analizowany przez system, a~następnie
  zostają mu udostępnione odpowiednie zasoby komputera. W~przypadku zakończenia działania procesu, system podejmuje akcje związane z~usunięciem zadania.
\par
%
\indent
  Każdy proces potrzebuje do działania co najmniej dwóch zasobów systemu operacyjnego, a~są nimi:
  \begin{enumerate}
    \item Czas procesora: czas ten jest porcjowany dla każdego procesu; system daje do dyspozycji zadania \emph{plasterek czasu} (ang. \emph{time slice}),
      po upływie którego (o~ile proces wcześniej nie oddał sterowania systemowi) proces będzie wywłaszczony. Do ustalenia, który proces ma otrzymać następny plasterek,
      stosuje się polityki długo\dywiz ~oraz krótkoterminowe, realizowane przez odpowiadających im \emph{planistów} (ang. \emph{schedulers}).
    \item Pamięć RAM: każdy proces działa w~\emph{wirtualnej przestrzeni adresowej} (ang. \emph{Virtual Address Space}). 
      Z~punktu widzenia systemu jest to funkcja, która przyporządkowuje \emph{wirtualnemu} adresowi komórki jej rzeczywisty adres w~RAM.
      Dzięki takiemu rozwiązaniu, możliwa jest izolacja procesów: każdy z~nich operuje w~rozłącznym podzbiorze pamięci RAM, bez możliwości
      odczytu/zapisu z/do podzbioru RAM przeznaczonego dla innego zadania.
      Stosowanie wirtualnej przestrzeni adresowej powoduje spory narzut czasowy na działanie procesu i~systemu. W~celu jego usprawnienia powstały mechanizmy 
      mające usprawnić zarządzanie pamięcią -- zarówno od strony sprzętowej
      (mechanizmy ochrony pamięci), jak i~programowej (udogodnienia na poziomie kompilacji).
  \end{enumerate}
  Oprócz tych dwóch zasobów, system z~reguły daje do dyspozycji procesu trzy urządzenia: standardowe wejście, wyjście oraz wyjście błędów.
\par
%
\indent
  Programy, a~więc i~odpowiadające im procesy, można podzielić na dwie zasadnicze grupy: interaktywne i~nieinteraktywne.
  Procesy z~pierwszej grupy najczęściej oczekują na reakcję użytkownika lub wystąpienie określonego zdarzenia w~urządzeniu systemowym,
  zaś procesy z~drugiej grupy nie potrzebują do swojego działania żadnej interakcji ze światem zewnętrznym.
\par
%
\indent
  Zarządzanie czasem procesora jest przede wszystkim powinnością planisty krótkoterminowego (ang. \emph{short--term scheduler}),
  zaś planista długoterminowy odpowiada za wybór procesów, które będą wczytane z~pamięci zewnętrznej do RAM. Planista długoterminowy
  jest uruchamiany rzadko w~porównaniu do uruchamiania planisty krótkoterminowego. Stąd, planista krótkoterminowy musi być wydajny.
  Jądro posiada także \emph{dyspozytora}, który odpowiada za wywłaszczanie procesów oraz przekazywanie do nich sterowania.
\par
%
\indent
  Zarządzanie pamięcią procesu jest zadaniem pracochłonnym: podczas przełączania pomiędzy dwoma procesami następuje zmiana 
  przestrzeni adresowej pierwszego procesu na przestrzeń adresową drugiego. Wiąże się to z~przełączeniem wirtualnej przestrzeni adresowej 
  wywłaszczonego procesu na przestrzeń następnego. Często wiąże się to z~wczytaniem sporej ilości danych z~RAM do pamięci podręcznej procesora.
\par
%
\indent
  Ponieważ każdy proces posiada dostęp do innych zasobów komputera, system musi sprawdzić ich stan oraz udostępnić informacje o~stanie procesowi
  (uaktualnić odpowiednie wartości PCB). Wykonanie tych czynności jest również znaczącym narzutem czasowym dla operacji przełączania procesów.
  Wątki, opisane w~rozdziale \ref{sec:motivation}, są naturalną konsekwencją ,,odchudzania'' procesów.
\par
\indent
  Koncepcja procesu oraz jego obsługa jest opisana wyczerpująco w~\cite{silberschatz} (rozdziały 4.1--4.3);
  w rozdziale 4.5 tej samej książki jest wiele szczegółów dotyczących realizacji wątków przestrzeni jądra; wspomniane są tam również wątki przestrzeni użytkownika,
  jak również obsługa włókien w~systemie Solaris 2.
\par
%
\subsection{Włókna}
\label{sec:fibers}
%
\indent
  Do niedawna niektóre systemy (Solaris do wersji 9, wczesne wersje NetBSD) udostępniały użytkownikowi włókna: kilka wątków przestrzeni użytkownika
  działało w~ramach jednego LWP, bez ograniczenia działających wątków przestrzeni użytkownika do jednego LWP.
  Implementacja włókien w~tych systemach była oparta na \emph{aktywacjach planisty} (ang. \emph{scheduler activations}) opisanych
  w~\cite{hennessy}, jednak
  w~związku ze znacznym spadkiem wydajności tych systemów, zrezygnowano z~udostępniania w~nich włókien.
  Co ciekawe, pomysł na udostępnienie włókien użytkownikowi został zrealizowany w~systemie Windows 7 (\emph{User Mode Scheduling}, UMS). Był on dostępny
  jedynie w~64-bitowym wydaniu tego systemu \cite{umshome}. Obecnie producent odradza jego użycie, zaś prace rozwojowe nad UMS zostały wstrzymane \cite{umscancel}.
  Istnieją jednak systemy, w~których włókna są wspierane, a~nawet rekomendowane jako domyślne rozwiązanie dla użytkownika. Przykładem takiego systemu jest
  AIX, produkt firmy IBM: Domyślny model wątków to M:N (M wątków użytkownika -- włókien jest wykonywanych w~N wątkach przestrzeni jądra) \cite{aixnote}.
\par
%
\indent
  Pomysł na implementację włókien bez dokonywania zmian w~systemie operacyjnym, a~co za tym idzie,
  biblioteka będąca implementacją włókien nie wymagających ingerencji w~jądro, nie jest oferowany w~żadnym systemie operacyjnym.
  Rozdział \ref{sec:solution} zawiera dokładny opis pomysłu oraz implementacji takiej biblioteki.
\par
%
\subsection{Linux}
\indent
  Linux traktuje procesy i~wątki w~jednakowy sposób; innymi słowy -- w~tym systemie nie istnieje pojęcie wątku: za wątek można uznać proces, który
  współdzieli przestrzeń adresową oraz dostęp do urządzeń systemowych.
  Takie podejście do wątków i~procesów jest możliwe dzięki dwóm mechanizmom:
  \begin{enumerate}
    \item Rozdzielenie wytworzenia procesu potomnego (operacja \function{fork}) od wczytania programu do pamięci i~jego uruchomienia (operacja \function{exec}).
    Dzięki takiemu podziałowi, do wytworzenia wątku wystarczy użyć operacji \function{fork}.
    \item \emph{Kopiowanie podczas zapisu} (ang. \emph{Copy On Write}, COW): po wywołaniu funkcji \function{fork}, obydwa procesy używają
    tej samej pamięci podczas odczytu. Jeśli proces potomny wykonuje operację zapisu do tej pamięci, wytwarzana jest dla niego nowa przestrzeń adresowa
    i~to w~niej jest zapisywana zmodyfikowana wartość poprzednio współdzielonego fragmentu pamięci. Od tej pory proces potomny używa już tego fragmentu pamięci 
    z~nowej przestrzeni adresowej. W~wypadku wątków, stosowany jest jeszcze prostszy mechanizm od COW, gdyż każdy wątek będący procesem potomnym używa tej samej
    przestrzeni adresowej, co proces macierzysty.
  \end{enumerate}
  Począwszy od tego rozdziału, wątki i~procesy będą traktowane podobnie, jak ma to miejsce w~systemach opartych na Linuksie: każda własność zadania powinna być
  rozumiana jako własność procesu lub wątku.
\par
%
\indent
  Wszystkie systemy zgodne ze specyfikacją POSIX \cite{POSIX} udostępniają mechanizm przełączania kontekstu wykonania w~przestrzeni użytkownika (ang. \emph{user\dywiz space context switching}).
  Mechanizm ten umożliwia zapisanie bieżącego kontekstu wykonania, a~następnie przekazanie sterowania do wcześniej przygotowanego kontekstu. W~odróżnieniu od mechanizmu wywłaszczania,
  wykonywany kontekst nie może być wstrzymany -- program wykonywany w~bieżącym kontekście wykonania musi \emph{dobrowolnie} wywołać procedurę przełączającą kontekst.
\par
%
\indent
  Funkcja \function{getcontext} \cite{setcontext} dostarcza użytkownikowi bieżący kontekst wykonania, zaś dzięki funkcji \function{makecontext} \cite{swapcontext} można wytworzyć nowy kontekst wykonania, który będzie uruchamiany wraz z~funkcją podaną
  jako jeden z~parametrów \function{makecontext}.
  Do przełączania pomiędzy kontekstami można użyć funkcji \function{setcontext} (\cite{setcontext}). Funkcja \function{swapcontext} \cite{swapcontext} dostarcza użytkownikowi spore udogodnienie: zapisuje bieżący kontekst oraz przekazuje sterowanie
  do docelowego kontekstu. Dzięki temu, łatwo jest przełączyć sterowanie do poprzedniego kontekstu.
  W~dalszej części tego dokumentu wystąpienie odwołania do \function{getcontext}/\function{swapcontext} będzie odnosić się do POSIX\dywiz owego mechanizmu przełączania kontekstu wykonania, czyli 
  czterech wymienionych wcześniej funkcji.
\par
%
\indent
  W Linuksie zaimplementowano mechanizm \code{epoll} \cite{epoll}: jest to mechanizm podobny do
  zawartego w~specyfikacji POSIX mechanizmu \code{poll} \cite{poll}, służy do cyklicznego sprawdzania stanu zasobów systemu w~nieblokujący sposób.
  \code{Epoll} jest szybszy od \code{poll}: dla zbioru obserwowanych zasobów wytwarzany jest identyfikator systemowy 
  (\emph{deskryptor}, ang. \emph{descriptor}) -- liczba całkowita, a~następnie każde zapytanie o~ten zbiór sprowadza się do zapytania
  o~konkretny deskryptor (kopiowana jest jedna liczba). W~przypadku mechanizmu \code{poll}, każde zapytanie o~stan zasobów to przesłanie zbioru obiektów (struktur),
  co pociąga za sobą kopiowanie tych obiektów z~przestrzeni użytkownika do przestrzeni jądra (przesłanie zapytania). Kiedy program obserwuje dużą liczbę
  zasobów systemowych, ich kopiowanie może wiązać się ze znaczącym narzutem czasowym na operację \code{poll}.
\par
\subsection{Synchronizacja zadań}
\label{sec:synchro}
\indent
\newcounter{notact} \setcounter{notact}{\value{tabmain}}
  System operacyjny udostępnia zadaniom ich własną przestrzeń adresową, na której mogą wykonywać operacje odczytu i~zapisu. Jeśli tej przestrzeni używa dokładnie jedno zadanie,
  to wynik operacji odczytu dowolnej komórki pamięci będzie aktualny do momentu wykonania zapisu innej wartości do tej komórki.
  Jeśli do jednej przestrzeni adresowej przypisane są co najmniej dwa procesy, wówczas wynik operacji odczytu może się zdezaktualizować. Najprostszy scenariusz, w~którym następuje
  dezaktualizacja wyniku operacji odczytu, przedstawia tabela \arabic{notact}.
  \begin{center}
    \begin{tabular}{|c|l|l|p{4cm}|}\hline
      \multicolumn{1}{|l|}{\parbox[t]{2cm}{Numer\\instrukcji}} & Zadanie 1 & Zadanie 2 & Uwagi \\ \hline
      1 & {\tt i~:= X } & & \\ \hline
      3 &  & {\tt j~:= X } & {Następuje przeplot: Zadanie 1 jest zatrzymane, następuje rozpoczęcie wykonania Zadania 2.} \\ \hline
      4 & & {\tt X~:= j + 1 } & \\ \hline
      5 & {\tt k~:= i } & & \\ \hline
    \end{tabular}
    \mytabcaption{Przykład zdezaktualizowanej operacji odczytu: począwszy od instrukcji 5 wartość {\tt i}~nie odpowiada faktycznej wartości komórki {\tt X}}
  \end{center}
  Problem ten może prowadzić do przekłamań, zaś w~większości wypadków jego wystąpienie może powodować niepoprawne działanie programu użytkownika.
  Podobne problemy występują w~sytuacji, gdy dostęp do danego zasobu posiada więcej niż jedno zadanie, np. gdy do jednego pliku może zapisywać kilka procesów.
\par
%
\indent
  W~celu uniknięcia niepożądanych sytuacji stosowane są różne techniki, m. in.:
  \begin{enumerate}
    \item Wzajemne wykluczanie: zastosowanie tej techniki gwarantuje, że ciąg instrukcji (zwany \emph{sekcją krytyczną}, ang. \emph{critical section})
      będzie wykonany przez dokładnie jeden proces, zaś inne procesy będą oczekiwać na jego zakończenie;
    \item Transakcje: proces może wykonać określony ciąg instrukcji dopiero po spełnieniu odpowiednich warunków. Wynik zostanie zapisany, a~dopiero wtedy inny proces będzie mógł operować na
      zasobach, które są związane z~daną transakcją. Jeśli jakikolwiek warunek transakcji nie zostanie spełniony, wówczas transakcja jest anulowana, a~jej wynik nie będzie zapisany;
    \item Protokoły: operacje zapisu do określonego zasobu (grupy zasobów) może wykonywać dokładnie jeden proces (\emph{właściciel zasobu}). 
      Każde zadanie w~wyniku wymiany określonej sekwencji komunikatów z~właścicielem odpowiedniego zasobu może pośrednio dokonać zapisu do tego zasobu.
  \end{enumerate}
  Każda z~tych technik posiada swoje zalety, żadna nie jest pozbawiona wad. Mogą one doprowadzić do:
  \begin{itemize}
    \item \emph{zakleszczenia} (ang. \emph{deadlock}) procesów: proces $A$~posiada dostęp do zasobu $Z_a$, próbuje uzyskać dostęp do zasobu $Z_b$, który jest zajęty przez proces $B$,
      $B$~próbuje uzyskać dostęp do zasobu $Z_c$, zajętego przez proces $C$, \ldots, proces $X$~posiada dostęp do zasobu $Z_x$ i~próbuje uzyskać dostęp do zasobu $Z_a$;
    \item \emph{zagłodzenia} (ang. \emph{starvation}) procesu przez inny proces: proces $A$~posiada dostęp do zasobu $Z_a$. Proces $B$~próbuje uzyskać dostęp do tego zasobu, ale jest on
      ciągle niedostępny dla $B$, w~efekcie $B$~zostaje zablokowany i~nie może być wykonany.
    \item spadku wydajności programu: jeśli liczba anulowanych transakcji jest znacząco większa od liczby transakcji zakończonych sukcesem (zapisem), to może dojść do sytuacji, w~której
      program nie będzie mógł wykonać założonego zadania w~czasie możliwym do przyjęcia przez użytkownika. Z~drugiej strony, zbyt skomplikowany protokół może powodować spore opóźnienie
      zapisu/odczytu do/z~zasobu.
  \end{itemize}
\par
%
\indent
  System operacyjny może udostępnić mechanizm wstrzymania procesu w~trakcie uzyskiwania przez tegoż dostępu do określonego zasobu lub nieblokującego dostępu do tego zasobu.
  Proces może jednak oczekiwać na dostęp, wykorzystując w~dalszym ciągu moc obliczeniową procesora. Taki sposób jest określany jako \emph{aktywne czekanie} (ang. \emph{busy waiting})
  i~w~większości sytuacji powoduje znaczący spadek wydajności systemu, jak i~pozostałych procesów.
\par
%
\indent
  Dokładny opis komunikacji międzyprocesowej  można znaleźć w~rozdziale 4.6 książki \cite{silberschatz}. Rozdział 6 zawiera opis synchronizacji procesów.
\par
%
\newpage
\section{Opis rozwiązania}
\label{sec:solution}
\subsection{Wstęp}
\indent 
  Biblioteka \code{libmixed}\footnote{Repozytorium zawierające kod źródłowy biblioteki \code{libmixed} jest dostępne pod adresem \url{https://www.github.com/hilander/mixed}.},
  powstała w~ramach niniejszej pracy magisterskiej, udostępnia użytkownikowi wątki hybrydowe (jednostki wykonalne zarządzane z~przestrzeni użytkownika,
  i~wykorzystujące wsparcie jądra). Spełnia wymagania wymienione w~rozdziale \ref{sec:target}, za wyjątkiem warunku \ref{enm:timesch}:
  istnieje komponent biblioteki odpowiedzialny za szeregowanie włókien, jednak \code{libmixed} nie kontroluje czasu wykonania pojedynczego włókna.
\par
\indent
  Biblioteka jest napisana w~języku C++. Jej kod źródłowy jest zgodny ze standardem C++2003 \cite{cpp2003}, 
  zostały wykorzystane w~nim udogodnienia z~biblioteki standardowej
  (STL -- \emph{STandard Library}, szczegółowo opisana w~\cite{stroustrup})
  oraz ,,sprytne'' wskaźniki (dokładniej -- \code{shared\_ptr}), 
  jak również mechanizm wiązania leniwego (\code{bind}) z~rozszerzenia TR1 \cite{cpptr1}, które stały się częścią
  biblioteki standardowej specyfikacji C++11 \cite{cpp11}.
  Do obsługi zasobów systemowych wykorzystywany jest mechanizm \code{epoll}.
\par
\indent
  \code{Libmixed} można rozpatrywać jako \emph{środowisko ramowe} (ang. \emph{framework}), które odpowiada za zarządzanie jednostkami wykonalnymi.
  Użytkownik biblioteki wytwarza i~uruchamia obiekt klasy \code{master}, która jest \emph{punktem wejścia} (ang. \emph{entry point}) ramy.
  Następnie wytwarza własne jednostki wykonalne: każda z~nich to obiekt klasy dziedziczącej po klasie \code{fiber}, która jest implementacją włókna.
  Kolejnym krokiem jest zgłoszenie żądania wykonania takiego obiektu, czym zajmuje się obiekt klasy \code{master}.
  Użytkownik musi mieć świadomość, że kolejność wykonania włókien nie musi zależeć od kolejności zgłoszenia żądań ich wykonania, co jest zgodne z~zasadą działania
  większości środowisk ramowych.
\par
\begin{center}
  \myownfigure{libmixedoverview}{libmixedOverview.png}{Zależności pomiędzy klasami biblioteki \code{libmixed}}{.7}
\end{center}
%
\indent
  Rysunek \arabic{libmixedoverview} zawiera opisane poniżej składniki biblioteki:
  \begin{itemize}
    \item \code{coroutine} jest podstawową klasą dla każdego włókna: dzięki niej włókno posiada swój własny kontekst wykonania -- a~więc można zapamiętać miejsce,
      w~którym następuje przerwanie działania danego włókna, a~następnie wznowić jego działanie;
    \item \code{fiber} zawiera udogodnienia dla użytkownika włókna (wymiana wiadomości, obsługa urządzeń systemowych, itp.);
    \item kolejki wiadomości (moduł \code{message\_queues}) umożliwiają szybką i~nieblokującą komunikację pomiędzy włóknami;
    \item planista (klasa \code{scheduler}) jest odpowiedzialny za szeregowanie włókien, przekazywanie sterowania oraz bezpieczny powrót z~kontekstu włókna i~przełączenie do innego włókna;
    \item \code{epoller} odpowiada za sprawdzenie zasobów systemowych używanych przez włókna;
    \item robotnik (klasa \code{worker}) zajmuje się wykonaniem jednego kroku framework\dywiz a, na który składają się:
      \begin{itemize}
        \item uruchomienie każdego włókna (do momentu, gdy włókno skończy działanie, albo zwróci sterowanie do planisty),
        \item wykonanie nasłuchu zasobów systemowych,
        \item sprawdzenie warunku stopu: jeśli jest spełniony, robotnik kończy pracę;
      \end{itemize}
    \item zarządca środowiska ramowego (klasa \code{master}) odpowiada za:
      \begin{itemize}
        \item uruchomienie wątków: każdy wątek to osobny robotnik; zakończenie działania robotnika jest równoznaczne zakończeniu działania odpowiadającego mu wątku,
        \item obsługę żądania uruchomienia włókna,
        \item komunikację z~robotnikami,
        \item pośredniczenie w~komunikacji pomiędzy włóknami zarządzanymi przez różnych robotników,
        \item sprawdzenia warunku stopu dla całego framework\dywiz a: jeśli warunek jest spełniony, rozsyła go do wszystkich robotników i~czeka na ich zamknięcie.
      \end{itemize}
  \end{itemize}
\par
%
\indent
  \myownfigure{libmixeddeployment}{Deployment.png}{Wykorzystanie wątków przestrzeni jądra przez \code{libmixed}}{.7}
  Rysunek \arabic{libmixeddeployment} przedstawia wykorzystanie wątków przez libmixed: każdy wątek odpowiada jednemu rdzeniowi w~komputerze, dlatego nawet wątek główny
  posiada swojego robotnika. Każde włókno, po przypisaniu do robotnika, jest wykonywane w~ramach wątku robotnika.
\par
\indent
  Należy pamiętać, że każda operacja wykonywana przez libmixed nie blokuje pracy robotników.
\par
\newpage
\subsection{Koprocedury -- klasa \code{coroutine}}
\label{sec:coroutine}
%
\indent
\newcounter{corotab} \setcounter{corotab}{\value{tabmain}}
  Pomysł oraz nazwa \emph{koprocedura} (ang. \emph{coroutine}) pojawiły się po raz pierwszy w~\cite{conway}.
  Koprocedura jest uogólnieniem pojęcia procedury, co pokazuje Tabela \arabic{tabmain}.
    \begin{center}
    \centering
    \begin{tabular}{|p{6cm}|p{6cm}|} \hline
      \multicolumn{1}{|c|}{Procedura} & \multicolumn{1}{c|}{Koprocedura} \\ \hline
      jeden punkt wejścia & jeden punkt wejścia \\ \hline
      {brak możliwości kontynuacji działania po wyjściu z~procedury} & {możliwość kontynuacji działania po wyjściu z~koprocedury } \\ \hline
      {jednorazowe przekazanie wyniku obliczeń} & {przekazanie częściowego wyniku obliczeń} \\ \hline
      współdzielony stos wywołań & własny stos wywołań \\ \hline
      współdzielony kontekst wykonania & własny kontekst wykonania \\ \hline
      współdzielony czas działania & współdzielony czas działania \\ \hline
    \end{tabular}
    	\mytabcaption{Porównanie procedury i~koprocedury}
    \end{center}
  Klasa \code{coroutine} jest implementacją koprocedury, a~więc udostępnia mechanizmy, dzięki którym możliwe jest osiągnięcie opisanych w~Tabeli \arabic{corotab} efektów.
  Należy mieć na uwadze, że \code{coroutine} wykorzystuje mechanizm \linebreak \code{getcontext()}/\code{swapcontext()}, dzięki czemu przełączanie pomiędzy koprocedurami jest wykonywane
  wyłącznie w~przestrzeni użytkownika.
  \myownfigure{Coroutine}{Coroutine.png}{Klasa coroutine - implementacja koprocedury}{.7}
\par
%
\indent
  Klasa \code{coroutine} udostępnia użytkownikowi m. in. następujące funkcje:
  \begin{enumerate}
    \item \function{init}: funkcja inicjalizująca koprocedurę. Każdy obiekt klasy \code{coroutine} musi być zainicjalizowany za pomocą tej funkcji,
      gdyż w~przeciwnym wypadku nie zostanie utworzony stos wywołań dla koprocedury, a~co za tym idzie -- działanie programu będzie przerwane, gdyż
      \function{init} wytwarza stos koprocedury, a~następnie jej kontekst (wywołuje \function{makecontext}.
    \item Funkcja \function{run} odpowiada za przełączenie bieżącego kontekstu wykonania na kontekst koprocedury: przełącza sterowanie na kontekst danej koprocedury oraz zapisuje kontekst,
      który ma być uruchomiony przy następnym przełączeniu sterowania (wywołanie \function{yield} lub wyjście z~funkcji \function{start}). \function{run} opakowuje 
      wywołanie \function{swapcontext}.
    \item Funkcje \function{start} oraz \function{go} są funkcjami abstrakcyjnymi, a~więc to użytkownik jest odpowiedzialny za ich implementację.
      Sugerowana implementacja tych funkcji jest następująca:
      \begin{itemize}
        \item \function{start} jest wywoływana \emph{po} przełączeniu sterowania do kontekstu koprocedury, \emph{powinna} wypełniać zadania
          związane z~działaniem koprocedury, tj. wywołać funkcję \function{go}, przechwytywać wyjątki, podjąć działania związane z~zakończeniem koprocedury;
        \item \function{go} \emph{powinna} być właściwym programem koprocedury.
      \end{itemize}
    \item Funkcja \function{yield} odpowiada za przekazanie sterowania z~bieżącej koprocedury do jednostki wykonalnej, która uprzednio przekazała sterowanie 
      tej koprocedurze. W~obecnej implementacji klasy \code{coroutine}, \function{yield} opakowuje \function{swapcontext}: przełącza sterowanie do uprzednio zachowanego kontekstu.
  \end{enumerate}
\par
%
\subsection{Klasa bazowa włókna -- \code{fiber}}
\label{sec:fibersClass}
    \myownfigure{Fiber}{Fiber.png}{Klasa fiber - implementacja włókna}{.7}
%
\indent
  \code{Fiber} jest klasą bazową dla włókien, które użytkownik zgłasza zarządcy (obiektowi klasy \code{master}) do uruchomienia. Dziedziczy po klasie \code{coroutine},
  dzięki czemu każde włókno posiada swój kontekst wykonania. Korzysta z~mechanizmów udostępnianych przez zarządzający nim obiekt klasy \code{worker}.
  Dzięki temu, \code{fiber} oferuje następujące udogodnienia:
  \begin{enumerate}
    \item Komunikacja: wymiana wiadomości z~innymi włóknami przy wykorzystaniu mechanizmów robotnika. 
      Po wytworzeniu wiadomości, można ją przesłać do odbiorcy za pomocą nieblokującej funkcji \function{send\_message}.
      Do odbioru wiadomości służą funkcje \function{receive\_message} (blokująca włókno) oraz \function{receive\_message\_nonblock} (nieblokująca).
    \item Wytworzenie włókna (wykorzystując mechanizmy robotnika): 
    \linebreak funkcja \function{spawn} umożliwia uruchomienie włókna przez zarządcę (obiekt klasy \code{master}).
      Funkcja ta może być wywołana jedynie przez działające włókno.
    \item Obsługa wejścia-wyjścia (wykorzystując mechanizmy robotnika):
      \begin{enumerate}
        \item blokujące operacje odczytu (\function{do\_read}) oraz zapisu (\function{do\_write});
        \item podstawowa obsługa gniazd sieciowych: funkcja \function{do\_connect} odpowiada systemowej operacji \function{connect}, a~funkcje \function{do\_accept} 
          \linebreak i~\function{do\_close} odpowiadają operacjom \function{accept} oraz \function{close}. Wywołanie każdej funkcji blokuje wykonanie włókna do momentu wystąpienia  
          zdarzenia związanego z~podanym deskryptorem.
      \end{enumerate}
    \item Przekazanie sterowania z~włókna do zarządcy -- funkcja \function{yield}, dziedziczona z~klasy \code{coroutine}.
  \end{enumerate}
  Należy pamiętać, że wymienione funkcje są blokujące jedynie dla wywołującego je włókna, praca robotnika (obiektu klasy \code{worker}, 
  który jest bezpośrednio odpowiedzialny za uruchomienie i~wstrzymanie działania powierzonych mu włókien) nie jest wstrzymywana.
\par
\indent
  Każde włókno posiada bufor używany podczas zapisu/odczytu do i~z~zasobów systemowych. 
  W~bieżącej implementacji jest on kolekcją standardową klasy \code{vector<char>},
  bezpośredni dostęp do bufora (dla włókna) zapewnia pole \code{rw\_buffer}, zaś funkcje \function{set\_last\_read} oraz \function{set\_last\_write} 
  informują o~ilości bajtów odczytanych/zapisanych podczas ostatnio wykonanej operacji odczytu/zapisu.
  Oprócz podanych wyżej funkcji, każde włókno posiada zestaw funkcji używanych przez zarządzające nim obiekty biblioteki:
  \begin{enumerate}
    \item Do ustawienia bieżącego stanu służy funkcja \function{set\_state}, a~\function{get\_state} informuje o~bieżącym stanie włókna.
    Włókno, ze względu na wykonywane operacje, znajduje się w~jednym ze stanów:
    \begin{itemize}
      \item \code{READY}: włókno gotowe do pracy;
      \item \code{FINISHED}: włókno zakończyło działanie;
      \item \code{BLOCKED\_FOR\_READ}: włókno zablokowane podczas próby odczytu z~zasobu systemowego;
      \item \code{BLOCKED\_FOR\_WRITE}:  włókno zablokowane podczas próby zapisu do zasobu systemowego;
      \item \code{BLOCKED\_FOR\_ACCEPT}:  włókno zablokowane podczas operacji \code{accept};
      \item \code{BLOCKED\_FOR\_CONNECT}:  włókno zablokowane podczas operacji \code{connect};
      \item \code{BLOCKED\_FOR\_MESSAGE}:  włókno oczekuje na nadejście wiadomości.
    \end{itemize}
    \item Funkcja \function{set\_owner} służy do ustawienia pola \code{owner}, które jest wskaźnikiem na obiekt klasy \code{worker} -- robotnika 
    zarządzającego włóknem. Pole to jest używane przez funkcje udostępnione dla użytkownika, a~odpowiedzialne za komunikację z~innymi włóknami oraz dostęp 
    do zasobów systemowych.
  \end{enumerate}
\par
\indent
  \myownfigure{LibcoroStates}{LibcoroStates.png}{Stany włókna oraz dozwolone przejścia pomiędzy nimi}{.55}
\par
\newpage
\subsection{Moduł \code{message\_queues}}
\label{sec:messagequeues}
%
\indent
  W~trakcie tworzenia składowych biblioteki \code{libmixed} chciałem, aby działanie programu używającego tego frameworka nie było przerywane:
  w~dowolnym momencie działania każdego wątku zarządzanego przez \code{libmixed} powinno być wykonywane włókno albo funkcja wywołana przez robotnika. 
\par
\indent
  Każdy robotnik zarządzany przez obiekt klasy \code{master} może komunikować się z~innymi robotnikami, a~także z~zarządcą. Każde włókno może komunikować
  się z~innymi włóknami, również tymi zarządzanymi przez robotników działających z~innymi wątkami.
\par
\indent
  Linux udostępnia mechanizmy do komunikacji międzywątkowej, jednakże posiadają one następujące wady:
  \begin{itemize}
    \item jądro systemu pośredniczy w~komunikacji, co wiąże się z~kopiowaniem przesyłanych danych (nadawca-jądro i~jądro\dywiz odbiorca);
    \item wykorzystanie tych mechanizmów jest proste w~wypadku, gdy są one używane w~sposób blokujący, zaś wykorzystanie ich w~nieblokujący
      sposób jest zadaniem skomplikowanym.
  \end{itemize}
  Biblioteka standardowa dostarcza kolekcje, które mogły by być użyte w~\code{libmixed}, jednakże nie gwarantują one bezpieczeństwa wątków
  (ang. \emph{thread safety}), co dyskwalifikuje je jako potencjalnych kandydatów do wykorzystania przez framework.
\par
\indent
  Rozwiązaniem tych problemów jest zaimplementowanie:
  \begin{enumerate}
    \item Kolekcji, która będzie bezpieczna w~warunkach wielowątkowego dostępu do jej elementów. Maksymalnie dwa wątki będą mieć dostęp
      do jednej kolekcji.
    \item Dwukierunkowego kanału komunikacyjnego, używanego przez maksymalnie dwa wątki. Dane przesyłane przez ten kanał nie muszą być kopiowane,
      ponieważ każda jednostka wykonalna w~ramach \code{libmixed} ma dostęp do tej samej przestrzeni adresowej.
  \end{enumerate}
  Zarówno kolekcja, jak i~kanał komunikacyjny, spełniające powyższe warunki zostały zaimplementowane od podstaw w~module \code{message\_queues}.
\par
\indent
    \myownfigure{MessageQueuesOverview}{MessageQueuesOverview.png}{Moduł \code{message\_queues} -- klasy i~zależności pomiędzy nimi}{.7}
\par
\indent
  Moduł \code{message\_queues} udostępnia użytkownikowi podstawową klasę wiadomości -- \code{message} oraz dwie klasy pochodne: \code{service\_message} oraz
  \linebreak \code{fiber\_message}, które służą do wymiany wiadomości odpowiednio pomiędzy zarządcami oraz włóknami. Dwa pola klasy \code{message}:
  \code{prev} oraz \code{next}, są wykorzystywane przez obiekt klasy \code{private\_list}.
\par
\indent
    \myownfigure{MessageQueue}{MessageQueue.png}{Klasa \code{message\_queue}}{.7}
\par
\indent
  Obiekt klasy \code{message\_queue} zawiera dwie nieblokujące listy komunikatów, które służą do wymiany wiadomości
  pomiędzy dwoma wątkami. Dla łatwej identyfikacji wątków, jeden z~nich został nazwany \code{master}, zaś drugi -- \code{slave},
  jednak są one traktowane jako dwie równorzędne jednostki wykonalne. Lista \code{master\_queue} służy do komunikacji \code{slave}$\to$\code{master},
  a~lista \code{slave\_queue} do \code{master}$\to$\code{slave}.
\par
\indent
    \myownfigure{PrivateList}{PrivateList.png}{Klasa \code{private\_list} -- nieblokująca lista dwukierunkowa, używana jako jednokierunkowy kanał do przesyłania wiadomości}{.7}
\par
\indent
  Obiekt klasy \code{private\_list} jest listą dwukierunkową. Wiadomości dodawane do niej nie są buforowane,
  jej rozmiar jest zależny jedynie od ilości dostępnej pamięci. Podczas dołączania lub pobierania wiadomości z~listy nie są stosowane żadne mechanizmy
  synchronizacji międzywątkowej. Użytkownik tej listy ma do dyspozycji dwie funkcje:
  \begin{enumerate}
    \item Funkcja \function{push} służy do dołączania wiadomości na koniec listy. Jej wywołanie zawsze jest zakończone sukcesem.
    \item Funkcja \function{top} służy do pobierania elementu \emph{głowy} listy (jej początku). Jeśli lista zawiera co najmniej jeden element, operacja się
    powiedzie (wynik wywołania -- \code{true}), w~przeciwnym wypadku wynikiem wywołania funkcji jest \code{false}.
  \end{enumerate}
  Żadna z~tych funkcji nie wykonuje jakiegokolwiek wywołania systemowego.
\par
\indent
  Każdy element listy, oprócz pól \code{prev} i~\code{next}, posiada również pole \code{used}, które jest używane do stwierdzenia, czy dany element był już
  użyty (\code{true}), czy jest gotowy do użycia (\code{false}).
  Lista posiada zawsze co najmniej jeden element, który jest jej \emph{głową} (\code{head}).
  Lista posiada również wiadomość o~ostatnim elemencie, \emph{wartowniku} (\code{guard}).
  W~szczególnym wypadku, \code{guard} może wskazywać na głowę listy. Lista pusta jest zatem reprezentowana przez dokładnie jeden element klasy
  \code{message}, którego pole \code{used} jest ustawione na \code{true}.
\par
\indent
  Funkcja \code{push( in m )} wykonuje następujące operacje na liście:
  \begin{enumerate}
    \item \code{m->prev} $\gets$ \code{guard};
    \item \code{guard->next} $\gets$ \code{m};
    \item \code{guard} $\gets$ \code{m}.
  \end{enumerate}
\par
\indent
  \myownfigure{PrivateListPush}{PrivateListPush.png}{Operacja \function{push}}{.7}
\par
\indent
  Implementacja funkcji \code{top( out m )} jest bardziej skomplikowana:\\
  Czy można użyć \code{head}?
  \begin{enumerate}
    \item TAK -- \code{m}$\gets$\code{head}
    \begin{enumerate}
      \item Czy \code{head->next}$\neq$\code{0}?
      \item TAK -- \code{head}$\gets$\code{head->next}, \code{head->prev->next}$\gets$\code{0}, \code{head->prev}$\gets$\code{0}.
      \item \code{return true}.
    \end{enumerate}
    \item NIE -- Czy \code{head->next}$\neq$\code{0}?
    \begin{enumerate}
      \item TAK -- \code{head}$\gets$\code{head->next}, \code{head->prev->next}$\gets$\code{0}, \code{head->prev}$\gets$\code{0}.
      \item \code{head->used}$\gets$\code{true}, \code{return true}.
      \item NIE -- \code{return false}.
    \end{enumerate}
  \end{enumerate}
\par
\indent
  \myownfigure{PrivateListPop1}{PrivateListPop1.png}{Operacja \function{top} -- pierwsza gałąź algorytmu}{.7}
  \myownfigure{PrivateListPop2}{PrivateListPop2.png}{Operacja \function{top} -- druga gałąź algorytmu}{.7}
\par
\indent
  Czy powyższa implementacja jest poprawna?
\par
\indent
  Aby pokazać poprawność tej implementacji, rozważmy sytuacje, w~których występuje przeplot operacji listowych wykonywanych przez
  wątki \code{master} oraz \code{slave}:
  \begin{enumerate}
    \item Gdy lista jest używana sekwencyjnie, każdy ciąg operacji \function{push} i~\function{top} nie zaburza wzajemnego położenia głowy i~wartownika (stan \emph{stabilny} listy).
    \item Podczas operacji \function{push} może wystąpić przeplot z~wątkiem wykonującym na tej samej liście operację \function{top}. 
    Gdy nowa wiadomość nie jest widoczna (rys. \arabic{PrivateListPush}),
    dowolny przeplot obydwu funkcji nie zaburza stanu stabilnego listy. Jedyna możliwość zaburzenia stanu stabilnego może wystąpić w~następującym scenariuszu:
      \begin{center}
      \centering
      \begin{tabular}{|c|c|c|c|} \hline
        Wątek               & Operacja                         & \code{head} & \code{guard} \\ \hline
        \code{master} (\function{push}) & \code{guard->next} $\gets$ \code{b} & \code{a} & \code{a} \\ \hline
        \code{slave} (\function{top})  & \code{head}$\gets$\code{b}          & \code{b} & \code{a} \\
                            & \code{b->prev->next}$\gets$\code{0} & \code{b} & \code{a} \\
                            & \code{b->prev}$\gets$\code{0}       & \code{b} & \code{a} \\ \hline
        \code{master}      & \code{guard}$\gets$\code{b}         & \code{b} & \code{b} \\ \hline
      \end{tabular}
      	\mytabcaption{Przeplot zaburzający stan stabilny listy}
      \label{tab:stableestate}
      \end{center}
    Jak łatwo zauważyć, zaburzenie to jest chwilowe, a~po zakończeniu wywołań funkcji w~przeplatających się wątkach lista wraca do stanu stabilnego. 
    Każde kolejne wywołanie funkcji \function{top} przy zablokowanym wywołaniu \function{push}
    nie zmieni żadnego dowiązania w~liście, gdyż element \code{b}~nie ma następnika.
    \item Jeśli wykonanie operacji \function{top} zostanie przerwane i~nastąpi przeplot z~funkcją \function{push}, która działa na tej samej liście,
    to każdy taki przeplot jest bezpieczny:
    \begin{enumerate}
      \item każdy przeplot operacji obu funkcji zachowuje stan stabilny listy;
      \item każda operacja wykonywana w~\function{top} dotyczy \emph{lewej strony} elementu listy (informacje dotyczące poprzednika), zaś
      operacje funkcji \function{push} dotyczą \emph{prawej strony} elementu.
    \end{enumerate}
  \end{enumerate}
\par
%
\newpage
\subsection{Klasa \code{scheduler}}
\indent
\myownfigure{Scheduler}{Scheduler.png}{\code{scheduler} -- planista włókien}{.7}
\par
\indent
  Każdy robotnik posiada dokładnie jeden obiekt klasy \code{scheduler}. Planista jest odpowiedzialny za:
  \begin{enumerate}
    \item Szeregowanie włókien: odpowiedzialna za to jest funkcja \function{run}. Do szeregowania włókien użyty jest algorytm \emph{round--robin}.
    \item Aktualizację włókna: może zmienić jego stan na \code{FINISHED} (po zakończeniu pracy włókna), może także zmienić obecnego właściciela włókna.
    \item Wykonanie włókien, które ma miejsce w~funkcji \function{run}. Planista posiada swój własny kontekst wykonania, który jest przekazywany do włókna
      podczas wywoływania \function{fiber\dcolon run}.
  \end{enumerate}
  Należy podkreślić, że funkcje składowe planisty wykonują wszystkie zadania związane z~szeregowaniem każdego włókna oraz uruchomieniem go we własnym kontekście wywołania.
\par
%
\newpage
\subsection{Klasa \code{epoller}}
\myownfigure{Epoller}{Epoller.png}{\code{Epoller} -- nakładka na mechanizm systemowy \code{epoll}}{.7}
\indent
  Rysunek \arabic{Epoller} przedstawia klasę opakowującą podstawowe operacje mechanizmu \code{epoll}.
  \code{Epoller} jest jedyną klasą w~\code{libmixed}, która bezpośrednio korzysta z~zasobów systemowych, zaś jej funkcje
  wywołują funkcje systemowe z~rodziny \code{epoll} (\function{epoll\_create}, \function{epoll\_wait}, \function{epoll\_ctl}).
\par
\indent
  Jak wspomniano wyżej, mechanizm ten umożliwia detekcję:
  \begin{itemize}
    \item zdarzeń dla zasobów systemowych (gotowość do wykonania operacji odczytu/zapisu, zakończenie lub wystąpienie błędu podczas operacji);
    \item nadejścia sygnału lub zdarzenia systemowego;
    \item upłynięcia zadanego czasu (ang. \emph{timer}).
  \end{itemize}
  W~obecnej implementacji biblioteki, obiekt klasy \code{epoller} jest wykorzystywany do wykrywania zdarzeń dla deskryptora danego zasobu.
  Użytkownik musi w~tym celu wykonać szereg wywołań funkcji systemowych, m. in. zgłosić systemowi operacyjnemu (za pomocą funkcji \function{fcntl}),
  że dostęp do zasobu ma być nieblokujący.
\par
\indent
  Obiekt klasy \code{epoller} udostępnia następujące funkcje:
  \begin{itemize}
    \item \code{add(int f)}: dodaje deskryptor urządzenia do obserwowanych;
    \item \code{del(int f)}: usuwa deskryptor urządzenia z obserwowanych;
    \item \function{do\_epolls}: oczekuje przez określony czas na wystąpienie zdarzeń;
    \item \function{get\_last\_epoll\_result}: podaje listę deskryptorów urządzeń, dla których wystąpiło zdarzenie.
  \end{itemize}
\par
%
\newpage
\subsection{Klasa \code{worker}}
\myownfigure{Worker}{Worker.png}{\code{Worker} -- robotnik działający w~obrębie jednego wątku}{.7}
\indent
  Każde włókno zarządzane przez robotnika posiada zagwarantowane:
  \begin{itemize}
    \item wykonanie -- robotnik zleca to zadanie swojemu planiście (pole \code{sched});
    \item dostęp do zasobów systemowych -- odpowiedzialny za tę funkcję jest posiadany przez robotnika obiekt klasy \code{epoller} (pole \code{io\_facility});
    \item komunikację z~innymi włóknami -- realizowaną przez obiekt klasy \linebreak \code{message\_queues} (pole \code{pipe}).
  \end{itemize}
\par
\indent
  Dostęp do zasobów systemowych  jest realizowany w~sposób przezroczysty dla włókna, zaś robotnik zleca obsługę zasobów obiektowi klasy \code{epoller}.
  \code{Worker} nie wykonuje więc żadnego wywołania funkcji systemowych.
  Funkcje \function{block\_on\_io} oraz \function{do\_connect} są wywoływane w~kontekście danego włókna i~blokują jego wykonanie (za pomocą wywołania funkcji \function{yield}) do momentu, w~którym 
  żądane zasoby systemowe będą dostępne. Stan włókna jest zmieniany i~odpowiada wykonywanej operacji:
  \begin{itemize}
    \item \code{BLOCKED\_FOR\_ACCEPT} odpowiada wywołaniu funkcji \function{accept};
    \item \code{BLOCKED\_FOR\_CONNECT} odpowiada wywołaniu funkcji \function{connect};
    \item \code{BLOCKED\_FOR\_READ} odpowiada wywołaniu funkcji \function{read};
    \item \code{BLOCKED\_FOR\_WRITE} odpowiada wywołaniu funkcji \function{write}.
  \end{itemize}
\par
\indent
  Dowolne dwa włókna mogą wymieniać między sobą wiadomości. Ze względu na przynależność włókien do zarządzających nimi robotników, możliwe są dwie sytuacje:
  \begin{enumerate}
    \item Obydwa włókna są zarządzane przez tego samego robotnika. Robotnik przesyła wiadomość do kolejki wiadomości włókna--odbiorcy.
    \item Każde włókno jest zarządzane przez innego robotnika. W~tej sytuacji robotnik wysyła wiadomość do nadzorcy (obiekt klasy \code{master}), żądając
      przesłania jej do wszystkich robotników w~systemie, nie oczekując na odpowiedź. Jeśli któryś z~robotników posiada włókno--odbiorcę wiadomości, zostanie ona
      przesłana do tego włókna. W~przeciwnym wypadku, wiadomość zostanie \emph{zignorowana}.
  \end{enumerate}
\par
\indent
  Robotnik, po wstępnej inicjalizacji, jest gotów do wejścia w~pętlę główną. Na każdy krok tej pętli (zawarty w~funkcji \function{iteration}), składają się następujące czynności:
  \begin{itemize}
    \item przegląda swoją kolejkę wiadomości, a~następnie podejmuje akcje odpowiednie do otrzymanych komunikatów (czynności zlecone przez zarządcę 
      lub przesłanie wiadomości do włókien);
    \item zleca planiście wykonanie wszystkich niezablokowanych włókien;
    \item zleca obiektowi klasy \code{epoller} sprawdzenie stanu (oraz dostępności) zasobów systemowych.
  \end{itemize}
  Możliwe jest również wykonywanie pojedynczego kroku pętli głównej robotnika (poprzez wywołanie \function{worker\dcolon iteration}).
\par
%
\newpage
\subsection{Klasa \code{master}}
    \myownfigure{Master}{Master.png}{Klasa \code{master} -- zarządca robotników}{.7}
%
\indent
  Obiekt klasy \code{master} wytwarza podległych mu robotników:  
  \begin{itemize}
    \item funkcja \code{init()} wytwarza dokładnie tylu robotników, ile rdzeni dostępnych dla aplikacji;
    \item funkcja \code{spawn()} służy do zgłoszenia włókna (włókien), które zostanie uruchomione (przekazane jednemu z~robotników) po wykonaniu funkcji \code{run()};
    \item funkcja \code{run()} jest wejściem do pętli głównej zarządcy. Wyjście z~pętli głównej następuje po ustaleniu warunku stopu;
    \item funkcja \code{its\_time\_to\_end()} sprawdza, czy został osiągnięty warunek stopu:
      \begin{itemize}
        \item żaden z~robotników nie obsługuje ani jednego włókna;
        \item \code{master} nie posiada żadnego włókna do uruchomienia.
      \end{itemize}
  \end{itemize}
\par
\indent
  Po wytworzeniu robotników, \code{master} pośredniczy w~komunikacji pomiędzy nimi, jak również sprawdza warunek stopu.
  Wytworzenie zarządcy jest realizowane za pomocą funkcji \code{create()}: 
  jest ona odpowiedzialna za inicjalizację robotników oraz uruchomienie ich w~odpowiadających im wątkach.
  Do komunikacji z~robotnikami \code{master} wytwarza kolejki wiadomości (dla każdego robotnika jest to obiekt klasy \code{message\_queue}.
  Funkcja \code{run\procbr} jest implementacją pętli głównej zarządcy. Dopóki nie zostanie spełniony warunek stopu,
  wykonywane są dwie czynności: odczyt i~reakcja na wiadomości przesłanych przez robotników oraz wykonanie jednej iteracji pętli głównej
  robotnika pracującego w~bieżącym wątku.
\par
\newpage
\section{Analiza rozwiązania}
\label{sec:analysis}
\subsection{Kryteria oceny}
\label{sec:criterions}
\indent
	Do oceny użyteczności przyjąłem następujące kryteria:
	\begin{enumerate}
		\item Wygody jej używania w~porównaniu z~dostępnymi implementacjami wątków. Ponieważ powszechnie używaną implementacją wątków jest \code{Pthreads} \cite{pthread},
      porównanie podstawowych scenariuszy użycia tej biblioteki z~analogicznymi scenariuszami użycia biblioteki \code{libmixed} powinno dać jasny pogląd
      na użyteczność \code{libmixed}.
    \item Poprawności działania poszczególnych elementów biblioteki na podstawie testów jednostkowych.
		\item Wydajności biblioteki \code{libmixed}, a~więc porównania czasu działania programów używających \code{libmixed}
      oraz analogicznych programów używających biblioteki \code{Pthreads}.
	\end{enumerate}
\par
%
\subsection{Wygoda użytkowania}
\indent
  Podstawowe scenariusze, na podstawie których można sprawdzić wygodę użytkowania biblioteki \code{libmixed}, to:
  \begin{enumerate}
    \item Uruchomienie środowiska zarządzającego włóknami.
    \item Wytworzenie włókna gotowego do uruchomienia.
    \item Uruchomienie włókna.
    \item Zakończenie działania włókna (po zakończeniu jego działania).
    \item Przesłanie wiadomości do innego włókna.
    \item Użycie zasobów systemowych
    \item Obsługa wyjątków.
  \end{enumerate}
  \newcounter{mixedpthread} \setcounter{mixedpthread}{\value{tabmain}}
\indent
  Tabela \arabic{mixedpthread} zawiera przykłady kodu źródłowego, jaki musi być dodany do programu użytkownika w~celu uzyskania
  wyżej wymienionych celów.
\par
  \begin{center}
  \centering
\footnotesize{
  \begin{tabular}{|c|l|l|} \hline
    Lp & \multicolumn{1}{c|}{\code{libmixed}} & \multicolumn{1}{c|}{\code{Pthreads}} \\ \hline
    1  & \parbox[t]{6cm}{\code{master\dcolon ptr m = master\dcolon create\procbr}}& \parbox[t]{6cm}{\code{--}} \\ \hline
    2  & \parbox[t]{6cm}{\code{class f:public fiber\{ {\ldots} \};\\myfiber f;\\f.init();}} & \parbox[t]{6cm}{\code{void f() \{ {\ldots} \};\\pthread:t t;}} \\ \hline
    3  & \parbox[t]{6cm}{\code{m->spawn( shared\_ptr(f) );}} & \parbox[t]{6cm}{\code{pthread\_create( \&t, 0, f, 0);}} \\ \hline
    4  & \parbox[t]{6cm}{zakończenie działania funkcji \code{f.go()}.} & \parbox[t]{6cm}{zakończenie działania funkcji \code{f()}.} \\ \hline
    5  & \parbox[t]{6cm}{\code{fiber\_message\dcolon ptr fm(new fiber\_message);\\fm->receiver = f';\\f.send\_message(fm);}} & \parbox[t]{6cm}{Brak dedykowanego rozwiązania} \\ \hline
    7  & \parbox[t]{6cm}{\code{f\dcolon start()\{\\try\{ go\procbr; \}\\catch( exception e ) \{ {\ldots}  \}\\\}}} & \parbox[t]{6cm}{\code{void go\procbr \{ {\ldots} \}\\void f\procbr\{\\try\{ go\procbr; \}\\catch( exception e ) \{ {\ldots}  \}\\\}}} \\ \hline
  \end{tabular}
}
  	\mytabcaption{Kod źródłowy potrzebny do realizacji scenariuszy 1~--~5 oraz~7}
  \end{center}
\par
\indent
  Scenariusz nr~6 składa się z~trzech kroków (zakładamy, że posiadamy dostęp do zasobu reprezentowanego przez \code{my\_socket}):
  \begin{itemize}
    \item odczyt 10 bajtów z~zasobu o~deskryptorze \code{my\_socket};
    \item zapis 10 bajtów do zasobu;
    \item zamknięcie zasobu.
  \end{itemize}
  Implementacja obsługi zasobu:
  \begin{enumerate}
    \item Przy użyciu \code{Pthreads}:
\begin{verbatim}
  count = ::read( my_socket, rdbuf, 10 );
  count = ::write( my_socket, sndbuf, 10 );
  ::close( my_socket );
\end{verbatim}
    \item Przy użyciu \code{libmixed}:
\begin{verbatim}
  // pobierane/zapisywane dane znajdują się w rw_buffer
  count = do_read( my_socket, 10 ); 
  count = do_write( my_socket, 10 );
  do_close( my_socket );
\end{verbatim}
  \end{enumerate}
\par
\indent
  Jak łatwo zauważyć, zarówno \code{Pthreads}, jak też \code{libmixed} nie wymagają od użytkownika wykonania skomplikowanych
  wywołań w~celu osiągnięcia pożądanych wyników. Tak więc \code{libmixed} jest \emph{równie} wygodna w~użyciu, jak \code{Pthreads}.
\par
\indent
  Uwaga: \code{Pthreads} oferuje większość mechanizmów synchronizacji międzywątkowej opisanej w~rozdziale \ref{sec:system}, podczas gdy \code{libmixed}
  oferuje użytkownikowi jedynie implementację wymiany komunikatów.
\par
\subsection{Testy jednostkowe}
\indent
  Testy jednostkowe zostały zaimplementowane przy użyciu \linebreak środowiska \code{GoogleTest}.
\par
\indent
  Testy jednostkowe należy podzielić na trzy grupy:
  \begin{enumerate}
    \item Testy koprocedur:
      \begin{enumerate}
        \item test operacji \function{yield}: przełączenie pomiędzy bieżącym kontekstem a~kontekstem koprocedury, również wielokrotne.
      \end{enumerate}
    \item Testy modułu \code{message\_queues}:
      \begin{enumerate}
        \item test klasy \code{private\_list}: przesyłanie wiadomości pomiędzy dwoma wątkami, z~których jeden prowadzi aktywny nasłuch (zapętlone wywoływanie
          funkcji \function{top});
        \item test klasy \code{message\_queue}: stabilne przesyłanie wiadomości w~obie strony pomiędzy dwoma wątkami;
      \end{enumerate}
    \item Testy zarządcy włókien wszystkich podległych mu elementów:
      \begin{enumerate}
        \item przesyłanie wiadomości pomiędzy dwoma włóknami -- w~ramach tego samego robotnika;
        \item przesyłanie wiadomości pomiędzy dwoma włóknami -- w~ramach dwóch różnych robotników;
        \item zwrócenie sterowania do zarządcy -- \function{yield};
        \item wytworzenie, inicjalizacja i~uruchomienie (\function{spawn}) nowego włókna przez bieżące.
      \end{enumerate}
  \end{enumerate}
  Wszystkie wymienione testy są spełnione przez bieżącą implementację włókna. Dlatego też można uznać, że jest ona przydatna w~sytuacjach zdefiniowanych
  przez te testy.
\par
\subsection{Testy wydajnościowe}
\indent
	Porównanie wydajności \code{libmixed} z~\code{Pthreads} można sprawdzić za pomocą następujących testów:
	\begin{enumerate}
		\item Czas wykonania \emph{pustych} jednostek wykonalnych (ang. \emph{null fork}) -- NF. Test ten da odpowiedź na pytanie o~wydajność biblioteki w~zakresie
      wytwarzania i~uruchamiania włókien. Liczba jednostek jest podstawowym parametrem tego testu: wraz ze wzrostem liczby obiektów do
      uruchomienia, będzie można zmierzyć również wzrost czasu ich obsługi.
    \item Czas wykonania przeplatających się jednostek wykonalnych (\emph{yields}) -- YT. Zarówno włókna, jak i~wątki mogą oddać sterowanie do zarządcy za pomocą wywołania funkcji 
      \function{yield}. Test ten można sparametryzować przez liczbę jednostek do wykonania oraz liczbę operacji \function{yield} wykonywanych
      w~pojedynczej jednostce wykonalnej.
		\item Czas zapisu danych na standardowe wyjście -- WT. Ten test można sparametryzować przez liczbę paczek danych do wysłania (każda w~osobnym obiekcie)
      oraz wielkość każdej pojedynczej paczki.
	\end{enumerate}
\par
\indent
  Konfiguracja maszyny, na której wykonano testy:
  \begin{itemize}
    \item procesor: 
      \begin{itemize}
        \item model: Pentium(R) Dual\dywiz Core  CPU      E5200  @ 2.50GHz;
        \item taktowanie procesora: 1200 MHZ;
        \item cache: 64 KiB pierwszego poziomu, 2 MiB drugiego poziomu;
      \end{itemize}
    \item pamięć RAM: 1 GiB, taktowana zegarem 800 MHz;
    \item system operacyjny Debian GNU/Linux:
      \begin{itemize}
        \item wersja jądra: 3.0.0-2-686-pae;
        \item wersja biblioteki \code{libstdc++}: 6.0.16.
      \end{itemize}
  \end{itemize}
\par
\indent
  Dla każdego parametru (pary parametrów) test został wykonany dziesięciokrotnie. Jeśli nie zaznaczyłem inaczej, za czas wykonania testu przyjąłem uśredniony 
  czas z~wszystkich 10 prób.
\par
\indent
  Należy wziąć pod uwagę fakt, iż testy były przeprowadzane w~otoczeniu ,,normalnych'' aplikacji, tj. współdzieliło czas wykonania z~charakterystycznymi składnikami
  systemu w~wersji \emph{desktop}, m. in.:
  \begin{itemize}
    \item X Window Environment;
    \item XFCE;
    \item odtwarzacz multimediów  (MPlayer);
    \item przeglądarka internetowa (Iceweasel -- ,,wolna'' (ang. \emph{free}) wersja przeglądarki Firefox).
  \end{itemize}
\par
\newpage
\subsubsection{Wyniki testu NF}
\indent
  NF pokazuje sprawność systemu w~zakresie wytworzenia oraz zakończenia działania jednostki wykonalnej.
  Wykonanie tego testu da odpowiedź na pytania odnośnie systemu operacyjnego, jak też \code{libmixed} w~zakresie
  wytworzenia nowych jednostek wykonalnych:
  \begin{itemize}
    \item Czy ze wzrostem liczby jednostek czas ich wykonania rośnie liniowo, czy w~inny sposób?
    \item Czy wytworzenie włókna daje zysk w~porównaniu do do wytworzenia wątku?
  \end{itemize}
\par
\indent
\myownfigure{nullfork}{nullfork.pdf}{Wykres porównawczy dla testu NF w~zależności od liczby pustych włókien lub wątków}{1.16} 
\par
\indent
Wyniki, widoczne na rysunku \arabic{nullfork}, dają jednoznaczną odpowiedź na postawione wyżej pytania: 
  \begin{itemize}
    \item zarówno dla wątków i~włókien, czas ich wytworzenia oraz uruchomienia rośnie liniowo;
    \item czas obsługi wątków jest kilkakrotnie dłuższy od czasu obsługi włókien.
  \end{itemize}
\par
%
\newpage
\subsubsection{Wyniki testu YT}
\indent
  YT posiada dwa parametry: \code{s}~--~liczbę jednostek wykonalnych do uruchomienia oraz \code{y}~--~liczbę wykonanych operacji 
  \function{yield} w~każdej z~jednostek.
\par
\indent
  \newcounter{yf1} \setcounter{yf1}{\value{figmain}}
  \newcounter{yf2} \setcounter{yf2}{\value{yf1}} \addtocounter{yf2}{1}
  \newcounter{yf3} \setcounter{yf3}{\value{yf2}} \addtocounter{yf3}{1}
  W~celu uzyskania wyników pozwalających na rzetelne porównanie \code{libmixed} i~\code{Pthreads}, wybrałem trzy serie testów dla następujących wartości
  \code{s}~i~\code{y} oraz $\mathbb{A}$=\{1, 101, 201, \ldots , 9901\}:
  \begin{enumerate}
    \item \code{s}=1, \code{y}~$\in \mathbb{A}$ (rys. \arabic{yf1}).
    \item \code{s}~$\in \mathbb{A}$, \code{y}=10 (rys. \arabic{yf2}).
    \item \code{s}~$\in \mathbb{A}$, \code{y}=100 (rys. \arabic{yf3}).
  \end{enumerate}
  
\par
\indent
\myownfigure{yield}{yield1n.pdf}{YT: \code{s}=1 i~\code{y}~$\in \mathbb{A}$}{1.16} 
  Pierwsza seria testów daje następujące informacje:
  \begin{itemize}
    \item operacja \function{yield} dla wątków jest zaimplementowana kilkakrotnie wydajniej niż funkcja \function{swapcontext}, wywoływana 
      przez implementację \function{yield} dla włókien;
    \item czas wykonania \function{yield} da wątków jest ograniczony od dołu jak i~od góry, w~odróżnieniu od ograniczenia czasu wykonania
      \function{swapcontext} (rysunki nr~\arabic{yf2} oraz \arabic{yf3} potwierdają tę tezę).
  \end{itemize}
\par
%
\indent
\myownfigure{yieldn10}{yieldn10.pdf}{YT: \code{s}~$\in \mathbb{A}$ i~\code{y}=10}{1.16} 
  Druga seria testów (rys. \arabic{yf2}) pokazuje taki scenariusz użycia włókien, który pozwala na wykonanie zadań w~wielu oddzielnych włóknach lub wątkach,
  przy rzadkim wywoływaniu operacji \function{yield}. Okazuje się, że w~takim scenariuszu wydajność biblioteki \code{libmixed}
  jest wyższa od wydajności Pthreads.
\par
%
\indent
\myownfigure{yieldn100}{yieldn100.pdf}{YT: \code{s}~$\in \mathbb{A}$ i~\code{y}=100}{1.16} 
  Ostatnia seria testów (rys. \arabic{yf3}) pokazuje, że w~ogólnym przypadku, tj. dla dużej liczby wywołań \function{yield} oraz dużej liczby wątków lub włókien,
  mechanizmy zaimplementowane w~\code{Pthreads} pozwalają kilkakrotnie szybciej wykonać zadane obliczenia, niż ma to miejsce w~wypadku \code{libmixed}.
\par
\newpage
\subsubsection{Wyniki testu WT}
\indent
  WT posiada dwa parametry: \code{n} -- liczba powtórzonych operacji zapisu oraz
  \code{s} -- długość napisów złożonych ze znaku \code{'.'}.
\par
\indent
  Poniżej przedstawiam wyniki testów dla następujących wartości \code{n}, \code{s} oraz zbiorów $\mathbb{B} = \{1,11,21,\ldots ,991\}$ i~$\mathbb{C} = \{1,1001,2001,3001,\ldots ,99001\}$:
  \newcounter{wf11} \setcounter{wf11}{\value{figmain}}
  \newcounter{wf12} \setcounter{wf12}{\value{wf11}} \addtocounter{wf12}{1}
  \newcounter{wf13} \setcounter{wf13}{\value{wf12}} \addtocounter{wf13}{1}
%
  \newcounter{wf21} \setcounter{wf21}{\value{wf13}} \addtocounter{wf21}{1}
  \newcounter{wf22} \setcounter{wf22}{\value{wf21}} \addtocounter{wf22}{1}
  \newcounter{wf23} \setcounter{wf23}{\value{wf22}} \addtocounter{wf23}{1}
%
  \newcounter{wf31} \setcounter{wf31}{\value{wf23}} \addtocounter{wf31}{1}
  \newcounter{wf32} \setcounter{wf32}{\value{wf31}} \addtocounter{wf32}{1}
  \newcounter{wf33} \setcounter{wf33}{\value{wf32}} \addtocounter{wf33}{1}
  \begin{enumerate}
    \item \code{n} $\in \mathbb{B}$, \code{s}=1000 (rys. \arabic{wf11}, \arabic{wf12}, \arabic{wf13}).
    \item \code{n}=1, \code{s}$\in \mathbb{C}$ (rys. \arabic{wf21}, \arabic{wf22}, \arabic{wf23}).
    \item \code{n}=100, \code{s}$\in \mathbb{C}$ (rys. \arabic{wf31}, \arabic{wf32}, \arabic{wf33}).
  \end{enumerate}
\par
\indent
  Pierwsza seria testów (rys. \arabic{wf11}, \arabic{wf12}, \arabic{wf13}) dała odpowiedź na pytanie o~wydajność operacji \function{do\_write} w~porównaniu z~blokującą operacją \function{write}.
\myownfigure{writen1000min}{writen1000min.pdf}{Wykres porównawczy dla \code{n}$\in \mathbb{B}$ i~\code{s}=1000 -- porównanie minimalnych czasów wykonania}{1.16} 
\myownfigure{writen1000max}{writen1000max.pdf}{Wykres porównawczy dla \code{n}$\in \mathbb{B}$ i~\code{s}=1000 -- porównanie maksymalnych czasów wykonania}{1.16} 
\myownfigure{writen1000avg}{writen1000avg.pdf}{Wykres porównawczy dla \code{n}$\in \mathbb{B}$ i~\code{s}=1000 -- porównanie uśrednionych czasów wykonania}{1.16} 
  Jak łatwo zauważyć, liczba wywołań \function{yield} nie wpływa na wydajność zapisu. Tak więc, wielokrotny zapis do urządzeń wejścia/wyjścia jest w~przypadku
  \code{libmixed} równie wydajny, co odpowiadający mu ciąg blokujących operacji zapisu przy użyciu Pthreads.
\par
\indent 
  Kolejna seria testów (rys. \arabic{wf21}, \arabic{wf22}, \arabic{wf23}) miała na celu sprawdzenie zapisu dla zbiorów danych o~różnej wielkości.
\myownfigure{write1nmin}{write1nmin.pdf}{Wykres porównawczy dla \code{n}=1 i~\code{s}$ \in \mathbb{C}$ -- porównanie minimalnych czasów wykonania}{1.16} 
\myownfigure{write1nmax}{write1nmax.pdf}{Wykres porównawczy dla \code{n}=1 i~\code{s}$ \in \mathbb{C}$ -- porównanie maksymalnych czasów wykonania}{1.16} 
\myownfigure{write1navg}{write1navg.pdf}{Wykres porównawczy dla \code{n}=1 i~\code{s}$ \in \mathbb{C}$ -- porównanie uśrednionych czasów wykonania}{1.16} 
  Okazuje się, że implementacja zapisu do zasobów systemowych w~\code{libmixed} jest równie efektywna jak blokujący zapis w~Pthreads. Co więcej, następna seria testów 
  (rys. \arabic{wf31}, \arabic{wf32}, \arabic{wf33}) pokazuje, że
  w~przypadku większej ilości operacji zapisu potwierdza to spostrzeżenie.
\par
\indent
\myownfigure{write100nmin}{write100nmin.pdf}{Wykres porównawczy dla \code{n}=100 i~\code{s}$ \in \mathbb{C}$ -- porównanie minimalnych czasów wykonania}{1.16} 
\myownfigure{write100nmax}{write100nmax.pdf}{Wykres porównawczy dla \code{n}=100 i~\code{s}$ \in \mathbb{C}$ -- porównanie maksymalnych czasów wykonania}{1.16} 
\myownfigure{write100navg}{write100navg.pdf}{Wykres porównawczy dla \code{n}=100 i~\code{s}$ \in \mathbb{C}$ -- porównanie uśrednionych czasów wykonania}{1.16} 
\par
\subsection{Podsumowanie testów}
\indent
  Na podstawie wyników opisanych wyżej testów, można wysunąć następujące wnioski:
  \begin{enumerate}
    \item Wygoda użycia \code{libmixed} jest porównywalna z~użyciem \code{Pthreads}.
    \item Działanie \code{libmixed} jest poprawne w~przestrzeni ograniczonej przez testy jednostkowe.
    \item Dzięki przeprowadzeniu testów wydajnościowych oraz porównaniu ich z~analogicznymi testami \code{Pthreads}, można stwierdzić
      następujące fakty:
      \begin{itemize}
        \item Wytworzenie włókna, a~więc wykonanie operacji \function{getcontext}, tj. wytworzenie niewielkiej (w~testowanym systemie jest to dokładnie 348 bajtów) struktury, 
          jest operacją szybszą niż wytworzenie nowego PCB za pomocą \function{pthread\_create}.
        \item Operacja \function{pthread\_yield} działa w~czasie kilkakrotnie krótszym niż operacja \function{swapcontext}.
        \item Zaimplementowana w~\code{libmixed} obsługa zasobów systemowych nie ustępuje efektywnością blokującemu dostępowi do tych urządzeń z~poziomu wątków.
      \end{itemize}
  \end{enumerate}
\par
\newpage
\section{Podsumowanie}
\label{sec:summary}
\subsection{Przydatność włókien}
\indent
  Włókna spełniające postulaty wymienione w~rozdziale \ref{sec:target} oraz implementacja włókien opisana w~rozdziałach
  \ref{sec:solution} oraz \ref{sec:analysis}, są niebanalną alternatywą dla wątków przestrzeni jądra:
  \begin{enumerate}
    \item Każde włókno, podobnie jak wątek, jest jednostką wykonalną posiadającą własny kontekst wykonania;
    \item Jądro systemu operacyjnego nie jest odpowiedzialne za zarządzanie włóknami, tj. szeregowanie oraz przekazywanie sterowania
      do włókna jest wykonywane w~przestrzeni użytkownika. Dzięki temu, system operacyjny może sprawniej wykonywać inne zadania,
      które nie mogą być wykonane w~przestrzeni użytkownika. Nawet drobna granulacja włókien 
      nie wpływa na spadek wydajności jądra systemu operacyjnego.
    \item System operacyjny jest odpowiedzialny jedynie za dostarczenie podstawowego mechanizmu nieblokującej obsługi
      zasobów systemowych, a~zadania związane z~obsługą włókien korzystających z~tych zasobów nie są jego zadaniem.
    \item Komunikacja pomiędzy włóknami jest realizowana również bez pośrednictwa systemu operacyjnego.
  \end{enumerate}
\par
\indent
  Biblioteka \code{libmixed} udostępnia użytkownikowi \emph{interfejs programowania aplikacji} (ang. \emph{Application Programming Interface, API}),
  który jest na tyle zbliżony do API oferowanego przez \code{Pthreads}, że ,,oswojenie'' z~nim dotychczasowego użytkownika \code{Pthreads}
  jest możliwe do zrealizowania w~krótkim czasie. Dodatkowym atutem \code{libmixed} jest fakt, iż został ona zaimplementowana przy użyciu języka C++.
  \code{Pthreads} (jak wszystkie elementy specyfikacji POSIX) udostępnia interfejs dla języka C, co wiąże się z~wytworzeniem interfejsu pośredniego w~C++,
  który pozwoli na wykorzystanie \code{Pthreads} wraz z~udogodnieniami oferowanymi przez język C++ oraz jego bibliotekę standardową.
  Wobec tych faktów:
  \begin{itemize}
    \item przejście z~\code{Pthreads} na \code{libmixed} jest zadaniem \emph{tanim} (ze względu na podobny interfejs);
    \item \code{libmixed} pozwala na użycie wszystkich udogodnień oferowanych przez język C++, zaś do podobnego użycia \code{Pthreads}
      należy wytworzyć warstwę pośrednią (zbiór tzw. \emph{wrapperów}).
  \end{itemize}
\par
\indent
  Należy pamiętać, że \code{libmixed} nie jest nową wersją wątków przestrzeni jądra, ani tym bardziej konkurencją dla \code{Pthreads} czy wątków opisanych w~specyfikacji C++11.
\par
\subsection{Podsumowanie implementacji}
\indent
  Użycie biblioteki \code{libmixed} nie powoduje spadku wydajności systemu operacyjnego. 
  Co więcej, jak podkreślono kilkakrotnie w~poprzednim rozdziale, jej użycie nie powoduje
  znaczącego spadku wydajności programu, który z~niej korzysta. 
  Zatem brak ingerencji w~działanie jądra nie przekreśla szans na wytworzenie wydajnej biblioteki włókien.
\par
%
\indent
  Opisana w~rozdziale \ref{sec:solution} implementacja jest wynikiem wielu prób stworzenia wydajnej biblioteki włókien. W~jednej z~nich (której zakończenie zostało zarzucone
  po wytworzeniu ok. 80\% kodu źródłowego oraz testów jednostkowych i~wydajnościowych) wykorzystałem inne niż round--robin metody szeregowania włókien.
  Okazało się, że metody szeregowania używające priorytetów zwiększały narzut czasowy na wykonanie programu. Round--robin, dzięki swej prostocie, jest szybkim 
  i~wydajnym algorytmem szeregowania włókien.
\par
%
\indent
  Z~punktu widzenia użytkownika \code{libmixed}, obsługa zasobów systemu operacyjnego jest synchroniczna (włókno jest blokowane do momentu zakończenia operacji odczytu/zapisu),
  jednak faktycznie nie jest blokowany wątek, w~którym wykonywane jest dane włókno.
  Dzięki tej właściwości, użytkownik może wytworzyć wiele włókien, które będą wydajnie zarządzane przez bibliotekę.
\par
\subsection{Kierunki rozwoju}
\indent
  \code{Libmixed} udostępnia podstawowe udogodnienia, dzięki którym możliwe jest korzystanie z~frameworka zaimplementowanego w~tej bibliotece,
  a~więc możliwe jest:
  \begin{itemize}
    \item wskazanie punktu wejścia włókna;
    \item korzystanie z~zasobów systemowych;
    \item komunikacja pomiędzy włóknami: jedynie wymiana komunikatów;
    \item przekazanie sterowania (wyniku częściowego);
    \item zakończenie działania włókna.
  \end{itemize}
  Udogodnienia te dają \emph{bazę} frameworka; na jej \emph{nadbudowę} powinny składać się mechanizmy znane z~\code{Pthreads}:
  \begin{itemize}
    \item mechanizmy synchronizacji: muteks, bariera, warunek;
    \item rozszerzone przekazywanie sterowania: implementacja przejmowania sterowania po upływie określonego plasterka czasu;
    \item wytworzenie innych kanałów komunikacji pomiędzy włóknami, analogicznych do tych udostępnianych przez system (np kolejek FIFO, potoków, sygnałów, itp.).
  \end{itemize}
  Należy pamiętać, że wymienione wyżej elementy nadbudowy \code{libmixed} należy zaimplementować zgodnie z~\emph{filozofią} biblioteki, to jest nie ingerując
  w~jądro systemu operacyjnego oraz nie \emph{pogarszać} wydajności elementów w~porównaniu do ich systemowych odpowiedników.
\par
\indent
  Celem opisanej nadbudowy biblioteki \code{libmixed} jest zbliżenie jej API w~jak największym stopniu do API oferowanego przez \code{Pthreads},
  co jeszcze bardziej poprawi jej atrakcyjność w~oczach dotychczasowych użytkowników \code{Pthreads}.
\par
\indent
  Innym kierunkiem rozwoju \code{libmixed} jest wytworzenie na jej bazie API identycznego z~nagłówkiem \code{<thread>}, przedstawionym
  w~standardzie C++11. Dzięki temu możliwe będzie wytworzenie frameworka alternatywnego do standardu, przyjętego przez cały świat.
  Dodatkową korzyścią, którą będzie można uzyskać, będzie możliwość idealnego dopasowania działania \code{libmixed} do wymagań standardu.
\par
%
\newpage
\rhead{\empty}
%\pagestyle{plain}
\bibliography{bibliography}
\end{document}
