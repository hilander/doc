<center><b>Co jeszcze zostało do zrobienia?</b></center>
Source:
+ General remarks
	* należy utworzyć szablon handle< Typename T> celem
		ujednolicenia dostępu do obiektów (na później?)
	* dodać tracer (na później?)
	* pomyśleć nad mechanizmem odtwarzania (replay) (na później?)
+ Coroutine
	* Wygląda na to, że wszystko OK
+ Manager
	* należy dokładnie określić odpowiedzialność tej przestrzeni nazw (oraz samej klasy)
	* gdzie umieścić kontenery? (w tej chwili znajdują się w scheduler)
+ Fiber
	* niewłaściwa nazwa plików / katalogów (używane jest runnable)
	* resource:
		- dospecyfikować (podstawowa klasa, klasy pochodne - te, które będą potrzebne do testów)
	* pipe:
		- zmienić nazwę (channel? two-way channel?)
		- ustalić protokół przesyłania / odbierania
		- zdarzenia specyficzne dla kanału
		- jest to zasób, dziedziczenie po resource?
	* message:
		- to powinien być szablon klasy, 
			= pierwszy argument typowy powinien być strukturą 
				zawierającej typ wyliczeniowy, w którym będą zdefiniowane przez użytkownika komunikaty 
			= drugi argument typowy powinien być strukurą zawierającą akcje, jakie będą podejmowane
				w przypadku nadejścia komunikatu
		- szatański pomysł: a gdyby struktura zawierająca enum użytkownika była szablonem:
			template< int StartValue > struct user_messages
			wtedy nie trzeba się martwić o kolizje wartości poszczególnych enumów.
			W takim przypadku należało by wypchnąć definicję enuma zawierającego podstawowe 
			komunikaty przed message.
		- doprecyzować przesyłanie komunikatów (endpointy, pośrednicy, zdarzenia(!))
	* runnable:
		- nazwa powinna być zmieniona na fiber
		- domyślne zasoby:
			= kanał wejściowy, wyjściowy
			= ?
	* socket:
		- wyspecyfikować!
		- dwa rodzaje (z punktu widzenia włókna):
			= blokujący
			= nieblokujący
	* file:
		- wyspecyfikować!
		- zrobić jacketing
		- dwa rodzaje dostępu (z punktu widzenia włókna):
			= blokujący
			= nieblokujący
+ Scheduler
	* scheduler (userspace)
		- nazwa nieadekwatna - zmienić na user[space]
		- zasoby:
			= określić zasoby używane przez schedulera
			= zaimplementować mechanizm obsługi zdarzeń
			= zaimplementować mechanizm obsługi sygnałów
			= zaimplementować jacketing dla I/O, socketów
		- określić politykę zarządzania włóknami, a następnie zaimplementować
	* ueber_sheduler
		- określić politykę zarządzania wątkami
		- określić politykę zarządzania zasobami
		- zaimplementować mechanizm komunikacji za pomocą kanałów

Doc:
+ Wstęp
	* taksonomia Flynn-a:
		- obszerna klasyfikacja systemów komputerowych (jednostka centralna + pamięć, liczba wejść i wyjść programu)
	* Systemy komputerowe:
		- bez ILP
		- ILP:
			= już zrobione (zgrubnie, można dodać przykłady tam, gdzie ich nie ma)
		- pamięć:
			= memory wall
	* Rozwój systemów operacyjnych:
		- Scheduling
			= bez schedulingu
			= batch processing
			= multiprocess
			= multithreading
