<center><b>Co jeszcze zostało do zrobienia?</b></center>
Source:
+ General remarks
	* należy utworzyć szablon <tt>handle< Typename T></tt> celem
		ujednolicenia dostępu do obiektów (na <i>później</i>?)
	* dodać tracer (na <i>później</i>?)
	* pomyśleć nad mechanizmem odtwarzania (replay) (na <i>później</i>?)
+ Coroutine
	* Wygląda na to, że wszystko OK
+ Manager
	* należy dokładnie określić odpowiedzialność tej przestrzeni nazw (oraz samej klasy)
	* gdzie umieścić kontenery? (w tej chwili znajdują się w scheduler)
+ Fiber
	* niewłaściwa nazwa plików / katalogów (używane jest runnable)
	* resource:
		- dospecyfikować (podstawowa klasa, klasy pochodne - te, które będą potrzebne do testów)
	* pipe:
		- zmienić nazwę (channel? two-way channel?)
		- ustalić protokół przesyłania / odbierania
		- zdarzenia specyficzne dla kanału
		- jest to zasób, dziedziczenie po resource?
	* message:
		- to powinien być szablon klasy, 
			= pierwszy argument typowy powinien być strukturą 
				zawierającej typ wyliczeniowy, w którym będą zdefiniowane przez użytkownika komunikaty 
			= drugi argument typowy powinien być strukurą zawierającą akcje, jakie będą podejmowane
				w przypadku nadejścia komunikatu
		- szatański pomysł: a gdyby struktura zawierająca enum użytkownika była szablonem:
			template< int StartValue > struct user_messages
			wtedy nie trzeba się martwić o kolizje wartości poszczególnych enumów.
			W takim przypadku należało by wypchnąć definicję enuma zawierającego podstawowe 
			komunikaty przed message.
		- doprecyzować przesyłanie komunikatów (endpointy, pośrednicy, zdarzenia(!))
	* runnable:
		- nazwa powinna być zmieniona na fiber
		- domyślne zasoby:
			= kanał wejściowy, wyjściowy
			= ?
	* socket:
		- wyspecyfikować!
		- dwa rodzaje (z punktu widzenia włókna):
			= blokujący
			= nieblokujący
	* file:
		- wyspecyfikować!
		- zrobić jacketing
		- dwa rodzaje dostępu (z punktu widzenia włókna):
			= blokujący
			= nieblokujący
+ Scheduler
	* scheduler (userspace)
		- nazwa nieadekwatna - zmienić na user[space]
		- zasoby:
			= określić zasoby używane przez schedulera
			= zaimplementować mechanizm obsługi zdarzeń
			= zaimplementować mechanizm obsługi sygnałów
			= zaimplementować jacketing dla I/O, socketów
		- określić politykę zarządzania włóknami, a następnie zaimplementować
	* ueber_sheduler
		- określić politykę zarządzania wątkami
		- określić politykę zarządzania zasobami
		- zaimplementować mechanizm komunikacji za pomocą kanałów

Doc:
+ Wstęp
	* taksonomia Flynn-a:
		- obszerna klasyfikacja systemów komputerowych (jednostka centralna + pamięć, liczba wejść i wyjść programu)
	* Systemy komputerowe:
		- bez ILP
		- ILP:
			= już zrobione (zgrubnie, można dodać przykłady tam, gdzie ich nie ma)
		- pamięć:
			= memory wall
		- urządzenia zewnętrzne
			= czas dostępu
			= odczyt, zapis
	* Rozwój systemów operacyjnych:
		- Scheduling (wstęp):
			= bez schedulingu
			= batch processing
			= multiprocess
			= multithreading
+ Zarządzanie procesami
	* wirtualna przestrzeń adresowa
	* podział czasu pomiędzy procesy
	* dostęp do zasobów
	* uruchamianie procesów potomnnych
	* IPC:
		- potoki anonimowe (pipes)
		- potoki nazwane (fifo)
		- kolejki komunikatów (message queues)
		- semafory
		- pamięć dzielona
		- gniazda (sockets)
			= UNIX Domain Sockets
+ Rodzaje wątków
	* wątki przestrzeni jądra (KLT)
	* wątki przestrzeni użytkownika (ULT)
+ Strategie zarządzania wątkami:
	* load sharing
		- trzy rodzaje:
			= first come first served (FCFS)
			= smallest number of threads first
			= preemptive smallest number of threads first
		- wady:
			= globalna kolejka dla wszystkich procesorów
				wymusza wzajemne wykluczanie
			= wywłaszczony wątek najczęściej trafia
				do innego procesora - problem z caching-iem
				(dużo cache-missów)
			= ponieważ wątki są składowane we wspólnej puli,
				w sytuacji gdy wymagają one ścisłej synchronizacji,
				przełączanie pomiędzy procesami staje się problematyczne
		- refinement: każdy procesor posiada własną kolejkę
			= istnieje globalna kolejka wątków, są one przekazywane do
				kolejek lokalnych
			= wątki z kolejki lokalnej posiadają wyższy priorytet niż
				wątki przekazane <i>ostatnio</i> z kolejki globalnej
	* gang scheduling
	* dedicated processor assignment
	* dynamic scheduling
+ Wątki mieszane
+ Koprocedury
	* "definicja"
	* przydatność ze względu na:
		- własny kontekst
		- możliwość zawieszenia obliczeń
		- możliwość powrotu do zawieszonych obliczeń

Testy:
+ Jednostkowe
+ Wydajnościowe
+ Porównawcze
